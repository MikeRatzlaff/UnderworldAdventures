 +--------------------------------------------------------------------------+
               Ultima Underworld 1 and 2 Formats Specification

                            Underworld Adventures
                        http://uwadv.sourceforge.net/
 +--------------------------------------------------------------------------+

Document version:
   $Id$


Table of Contents
-----------------

   1      Introduction

   2      Overview
   2.1    Remarks
   2.2    Summary of game files
   2.2.1  Ultima Underworld 1 files
   2.2.2  Ultima Underworld 2 files

   3      Graphics and visuals
   3.1    Palettes
   3.2    Images
   3.3    Bitmaps
   3.4    Textures
   3.5    Fonts
   3.6    Critter animations
   3.7    Cutscene animations

   4      Level maps and object lists
   4.1    Level map
   4.2    Master object list
   4.3    Free lists

   5      String resources

   6      Objects and items
   6.1    List of all objects and items
   6.2    Common object properties
   6.3    Object class properties
   6.4    Item combining

   7      Conversations

   8      3d models

   9      Miscellaneous stuff

 +--------------------------------------------------------------------------+


1  Introduction

   <-- start here

 +--------------------------------------------------------------------------+


2  Overview

   This chapter gives a short overview over the game itself, as well as a
   detailed summary about all game files used in Ultima Underworld 1 and 2.


2.1  Remarks

   Ultima Underworld is a MS-DOS based game created in C with Turbo-C and
   Optasm as the assembler used.


2.2  Summary of game files

   This section lists all the files that are part of the Ultima Underworld
   game installations.


2.2.1  Ultima Underworld 1 files

   Here's a list of all files for Ultima Underworld 1:

   Files in the main folder:

   install.dat    infos which files are installed
   install.exe    installer created with EZ-INSTALL 3.13
   install.olb    ANSI text strings for the installer
   lha.doc        LHA manual for 2.13
   lha.exe        LHA 2.13 to unpack installer game files
   uw.exe         ultima underworld 1 executable
   uwsound.exe    sound settings program

   Files in the "data" folder:

   3dwin.gr       3d window graphics
   allpals.dat    auxilliary 4-bit palette indices
   animo.gr       small animations
   armor_f.gr     female paperdoll armor graphics
   armor_m.gr     male paperdoll armor graphics
   babglobs.dat   initial conversation globals
   blnkmap.byt    blank map bitmap, palette #1
   bodies.gr      paperdoll bodies
   buttons.gr     buttons, seems to be from some map editor
   chains.gr      rotating chains for the stats window
   chargen.byt    character generation bitmap, palette #3
   charhead.gr    character images, for conversations
   chrbtns.gr     character generation graphics, palette #3
   chrgen.dat
   cmb.dat        item combining rules
   cnv.ark        conversation scripts
   comobj.dat     common object properties
   compass.gr     compass graphics
   conv.byt       seems to be a conversation screenshot, palette #0
   converse.gr    conversation screen bitmaps
   cursors.gr     mouse cursor images
   doors.gr       doors textures (may be decals)
   dragons.gr     scroll dragons animations
   eyes.gr        eyes from top screen
   f16.tr         floor/ceiling textures, size 16x16
   f32.tr         floor/ceiling textures, size 32x32
   flasks.gr      health and mana flask graphics
   font4x5p.sys   small font
   font5x6i.sys   italic font, used in character stats screen
   font5x6p.sys   normal font, used for scroll messages
   fontbig.sys    big font, for cutscenes
   fontbutn.sys   font for buttons (?)
   fontchar.sys   character generation font (?)
   genhead.gr     generic heads images
   grave.dat      grave IDs
   heads.gr       avatar character generation heads
   inv.gr         inventory graphics, scroll backgrounds (?)
   lev.ark        level maps, texture indices and object list
   lfti.gr        left menu buttons
   light.dat      palette mappings for 16 different light levels
   lights.dat
   main.byt       main game screen bitmap, palette #0
   mono.dat       palette mapping for grayscale colors
   objects.dat    object data specific to an object class
   objects.gr     object graphics, some never seen in inventory (460 objects!)
   opbtn.gr       opening screen buttons, create new game, etc.; palette #2
   opscr.byt      opening screen, palette #2
   optb.gr        some options buttons
   optbtns.gr     all options buttons from the left menu
   pals.dat       eight palettes (#0 to #7; #5 and #6 are the same)
   panels.gr      some invalid type, 0x0 and 1x1 resolution images
   player.dat     initial player character called "gronkey"
   power.gr       hit power indicator graphics
   pres1.byt      "origin presents" screen, palette #5
   pres2.byt      "a blue sky prod. game" screen, palette #5
   question.gr    a single question mark
   scrledge.gr    scroll paper edges
   shades.dat
   skills.dat     char. generation skills for all classes
   spells.gr      spells graphics
   strings.pak    all the game strings
   terrain.dat    terrain texture properties (see 8.3)
   tmflat.gr      wall switches and other decals
   tmobj.gr       more wall decals, 3d model textures
   uw.cfg         underworld configuration (audio, cut scenes)
   views.gr       the letters "mv", probably not used
   w16.tr         wall textures, size 16x16
   w64.tr         wall textures, size 64x64
   weapons.cm
   weapons.dat
   weapons.gr     weapon hit animations, for left and right handedness
   win1.byt       winning screen with text, palette #7
   win2.byt       blank winning screen for character info, palette #7
   xfer.dat

   Files in the "sound" folder:

   XX.voc         all cutscene audio files
   uwXX.xmi       underworld extended midi music
   awXX.xmi       the same, for adlib music (?)
   sounds.dat     sound effect midi commands (?)
   uw.mt          MT32 sysex data
   uw.ad          adlib stuff
   *.adv          device driver for midi/wave output:

   adlib.adv      Ad Lib Music Synthesizer Card
   mt32mpu.adv    Roland MT-32 or compatible
   pasdig.adv     Pro Audio Spectrum Digital Sound
   pasfm.adv      Pro Audio Spectrum FM Sound
   pcspkr.adv     IBM PC or compatible internal speaker
   sbdig.adv      Sound Blaster Digital Sound
   sbfm.adv       Sound Blaster FM Sound
   sbpdig.adv     Sound Blaster Pro Digital Sound
   sbpfm.adv      Sound Blaster Pro FM Sound
   tandy.adv      Tandy 3-voice internal sound

   Here's a list of song names for the .xmi files:

   uw01.xmi       Introduction
   uw02.xmi       Dark Abyss
   uw03.xmi       Descent
   uw04.xmi       Wanderer
   uw05.xmi       Battlefield
   uw06.xmi       Combat
   uw07.xmi       Injured
   uw10.xmi       Armed
   uw11.xmi       Victory
   uw12.xmi       Death
   uw13.xmi       Fleeing
   uw15.xmi       Maps & Legends

   Files in the "cuts" folder:

   * = not in "static" install

   cs???.n00   anim control files (?)

   cs000.n01   black screen
   cs000.n02 * garamon in swirling air
   cs000.n03   garamon talking
   cs000.n04 * garamon talking
   cs000.n05 * garamon talking
   cs000.n06 * garamon in swirling air
   cs000.n07   garamon appearing
   cs000.n10   intro w/ tyball stealing princess, troll and guards etc.
   cs000.n11   almric talking, on throne
   cs000.n12   almric talking, closeup
   cs000.n15   guard talking
   cs000.n16 * guard talking
   cs000.n17 * guard talking
   cs000.n20   mountain scene, avatar taken to the abyss
   cs000.n21 * mountain scene
   cs000.n22   abyss doors closed, from outside
   cs000.n23   doors closed, from inside, w/ avatar
   cs000.n24   guard talking, with purple background
   cs000.n25 * guard talking, with purple background

   cs001.n01   ship approaching, abyss collapsing
   cs001.n02   ship taking avatar on board
   cs001.n03   almric talking, on ship
   cs001.n04   almric talking, on ship
   cs001.n05 * almric talking, on ship, birds in background
   cs001.n06   arial talking
   cs001.n07   arial talking
   cs001.n10   abyss collapsing, ship sails away

   cs002.n01   dying tyball talking
   cs002.n02 * dying tyball talking
   cs002.n03 * dying tyball talking
   cs002.n04 * dying tyball, dying

   cs003.n01   arial talking
   cs003.n02 * arial talking

   cs011.n01   "ultima underworld the stygian abyss" splash screen anim
   cs012.n01   acknowledgements
   cs013.n01   goblet with letters "in"
   cs014.n01   goblet with letters "sa"
   cs015.n01   goblet with letters "hn"

   cs400.n01   "look" graphics for windows to abyss volcano core
   cs401.n01   grave stones

   cs402.n01   death skulls w/ silver sapling
   cs403.n01   death skulls animation
   cs403.n02   death skull end anim

   cs404.n01   anvil graphics
   cs410.n01   map piece showing some traps

   Files in a save game folder (e.g. "Save1"):

   lev.ark        modified level map
   bglobals.dat   conversation globals (initialized)
   desc           savegame name
   player.dat     character info

   Files that only appear in the uw_demo "data" folder:

   df??.tr        floor textures
   dmain.byt      main screen
   dplayer.???    encrypted player character info for self-running demo
   dscript.???    scripts for self-running demo sequences
   dterrain.dat   terrain texture properties for the demo
   dw??.tr        wall textures
   level13.anx    object animation overlay info
   level13.st     tilemap and master object list for first level
   level13.txm    level texture usage for first level
   newobj.dat
   presd.byt      "... presents a demo of ..." screen for the demo


2.2.2  Ultima Underworld 2 files

   Here is a list of all files from Ultima Underworld 2 that differ in content
   or are only available in the second game.

   Files in the main folder:

   uinstall.exe   game installer (LZEXE 0.91 compressed)
   uw2.exe        Ultima Underworld 2 game

   Files in the "data" folder:

   byt.ark
   cnv.ark        compressed conversation archive
   dl.dat
   gempt.gr       red gem parts (?)
   ghed.gr
   lev.ark        compressed levelmap archive
   lighting.dat
   pals.dat       11 palettes
   scd.ark
   weap.cm
   weap.dat

   Files in the "cuts" folder:
   lback00x.byt   (?) (x = 0..8)

   Files in the "crit" folder:

   as.an
   cr.an
   pg.mp
   crXX.YY        critter animations, XX=animation(octal) YY=page

   Files in the "sound" folder:

   bsp??.voc
   dd??.adv       digital sound drivers
   dm??.adv       digital music drivers
   sample.opl
   sp??.voc
   uw.opl
   uw??.voc
   uwa??.xmi
   uwr??.xmi

   Here's a list of song names for the .xmi files:

   uwa01.xmi
   uwa02.xmi
   uwa03.xmi
   uwa04.xmi
   uwa05.xmi
   uwa06.xmi
   uwa07.xmi
   uwa10.xmi
   uwa11.xmi
   uwa12.xmi
   uwa13.xmi
   uwa14.xmi
   uwa15.xmi
   uwa16.xmi
   uwa17.xmi
   uwa30.xmi
   uwa31.xmi

 +--------------------------------------------------------------------------+


3  Graphics and visuals

   This chapter explains all visual formats used, e.g. wall/floor/ceiling
   textures, user interface images or animations.


3.1  Palettes

   Ultima Underworld uses several palettes for different purposes. There are
   palettes with 256 indices, as well as auxiliary meta-palettes that have
   16 or 32 entries that map indices to the 256-index map. As the original
   games directly load the palettes into the VGA registers, effects as color
   flashs done with palette rotating is possible.


3.1.1  256 color palettes

   In the file "palette.dat" there are stored 8 different palettes. A palette
   has the following layout:

   0000  Int8  blue  intensity, index 0, range [0..63]
   0001  Int8  green intensity, index 0, range [0..63]
   0002  Int8  red   intensity, index 0, range [0..63]

   0003  Int8  blue  intensity, index 1, range [0..63]
   0004  Int8  green intensity, index 1, range [0..63]
   ...

   In each palette there are stored color intensities for 256 colors. All 8
   palettes are stored sequentially in the file.

   Palette index 0 always means a transparent color.


3.1.2  16 color auxiliary palette mappings

   In "allpals.dat" there are several auxiliary palettes, used for 4-bit
   images. All indices use palette #0.

   0000  Int8  index to first color
   0001  Int8  index to second color
   ...

   There are 16 values that are indices for palette #0. They build a 16 color
   palette from selected colors of the palette #0.

   In the file "allpals.dat" there are stored 0x1f (=31) such palettes.

   The critter animations (explained in chapter 3.6) use 32 color auxiliary
   palette mappings. They are stored withun the animation files.


3.1.3 Palette mappings

   Palette mappings for different light/darkness levels are stored in the
   file "light.dat". The file consists of 16 blocks of palette mappings. Each
   block contains 256 Int8 values which map colors to their palette indices in
   the game palette. The first block is the mapping for original colors, and
   the last one is for "almost black".

   The file "mono.dat" contains palette mappings that maps colors to grayscale
   values. It has the same format as the "light.dat" file and can be
   interchanged to get a gray underworld look. It is used for the spell
   "invisibility".


3.1.4  Palette rotation animations

   In several places of the game the palette is used to create animated
   effects, such as the lava and water textures. Here are the palette indices
   that have to be rotated to produce the animations:

   - Palette #0: in game graphics

    indices 16 through 23: lava fire effect
    indices 48 through 51: water effect

   - Palette #2: game start screen

    indices 64 through 127: "Ultima Underworld" logo warping effect


3.2  Images

   Graphics are stored in "*.gr" files and can be stored with 8-bit or 4-bit
   indices.

   0000  Int8   unknown, always seems to be 1
   0001  Int16  number of bitmaps
   0003  Int32  offset to bitmap #0
   0007  Int32  offset to bitmap #1
   ...

   Each bitmap has its own header:

   0000  Int8   bitmap type:
                04: 8-bit uncompressed
                08: 4-bit run-length
                0A: 4-bit uncompressed
   0001  Int8   width
   0002  Int8   height

   For the 4-bit formats, there follows another Int8 that selects the
   auxiliary palette to use (see 2.1).

   000n  Int16  size of data for the bitmap.
                in 4-bit formats, this is the number of 4-bit nibbles, not
                bytes.

   The file "panels.gr" contains bitmaps that don't have a bitmap header, but
   immediately starts with image data. The bitmaps are of type 04 and have
   a width of 83 and a height of 114 pixels.


3.2.1  Uncompressed bitmaps (04: 8-bit, 0A: 4-bit)

   All palette indices are stored sequentially, first one line, then the
   next, and so on. For the 4-bit format, first take the upper nibble, then
   the lower nibble.


3.2.2  Compressed bitmaps (type 08)

   All pixels are run-length encoded. when a new byte has to be retrieved,
   first take the high nibble, then the low nibble of that byte.

   Data consists of repeat and run records. Repeat records let the decoder
   repeat a single nibble a certain number of times. The run record takes
   a certain number of next nibbles to be as uncompressed. The two records
   alternate in the bitmap, starting with a repeat record.

   For every record, first there is a count to retrieve. Get a nibble; if
   it is not 0, it is a count. Otherwise, get two more nibbles, n1 and n2.
   The count is  c = (n1 << nibblesize) | n2. If the count is still zero,
   take another three nibbles, and calculate the count:

     c = (((n1 << nibblesize) | n2) << nibblesize) | n3;

   A count is at most 6 nibbles long.

   A run record consists of a count and then follows 'count' nibbles,
   that are the raw pixel data. A repeat record consists of a count and
   a single nibble, the nibble is then repeated 'count' times.

   As there is no point in repeating a nibble <3 times, there are some
   special meanings for count:
   1: skip this record, the next one is a run record again. may be used at
      the beginning of a file, when it should start with a run rather than
      a repeat.
   2: multiple repeats. get another count, and process 'count' times a
      repeat record.

   NOTE that there also exists a 5-bit compressed format which is exactly
   the same as the above except that the word length is 5 bits instead of 4.
   This is used for critter animation frames in the crit/ folder. The
   auxiliary palette contains 32 entries and is stored with the animation.


3.3  Bitmaps

   Bitmaps in Ultima Underworld 1 are stored in "*.byt" files. They just are
   320x200 bitmaps using different palettes. Here's a list of all bitmap
   files:

   blnkmap.byt    blank map bitmap, palette #1
   chargen.byt    character generation bitmap, palette #3
   conv.byt       seems to be a conversation screenshot, palette #0
   main.byt       main game screen bitmap, palette #0
   opscr.byt      opening screen, palette #2
   pres1.byt      "origin presents" screen, palette #5
   pres2.byt      "a blue sky prod. game" screen, palette #5
   win1.byt       winning screen with text, palette #7
   win2.byt       blank winning screen for character info, palette #7

   Underworld 2 has no "*.byt" files. Instead there is one "byt.ark" that
   contains all images. Like every other "*.ark" file this starts with some
   tables followed by the data, in this case the images themselves. There are
   11 entries, of which only 9 are valid:

   entry   palette   usage
    0       1        Map framework - background, crystal, and the like
    1       0        Character generation
    2       0        Bartering
    3                -unused-
    4       0        HUD - the frame, bottles, scroll
    5       0        Underworld 2 Main menu - without menu entries
    6       5        Origin presents
    7       5        Looking Glass Technologies
    8       0        Congratulation screen
    9       0        like the above but without the text
   10                -unused-


3.4  Textures

   Textures are stored in "*.tr" files, where "fXX.tr" files are floor/ceiling
   textures, and "wXX.tr" are wall textures. XX describes the width and height
   resolution of the texture (textures are always square).

   0000  Int8   unknown, always seems to be 2
   0001  Int8   x and y resolution
   0002  Int16  number of textures in file
   0004  Int32  offset to texture #0
   0008  Int32  offset to texture #1
   ...

   The offset of each texture points to the actual texture palette indices,
   which are xyres^2 bytes long. Textures always use palette #0.

   Texture names are stored in string block 10, where wall textures start at
   position 0, and ceiling textures start at 510, going backwards. The string
   at position 511 is reserved for the ceiling.


3.5  Fonts

   Fonts are stored in "font*.sys" files, and can be non-proportional (chars
   can have different lengths). The header looks as this:

   0000  Int16   unknown, always 1 (might be size of character width field)
   0002  Int16   size of single character, in bytes (=charsize)
   0004  Int16   width of the blank (space) character, in pixels
   0006  Int16   font height in pixels
   0008  Int16   width of a character row in bytes
   000A  Int16   maximum width of a character in pixels (=maxwidth)

   Then follow all bitmaps for each character. The number of chars can be
   determined by (filelen-12) / (charsize+1). Bitmaps are stored as 1-bit
   patterns, starting at the most significant bit in the current byte. When
   a new line in character bitmap begins, remaining bits are unused and a new
   byte in the file is taken.

   After 'charsize' number of bytes, there is another Int8 that says the width
   for the current character in pixels.

   Note: at least the fonts "fontbig.sys" and "font5x6p.sys" contain overly
   large characters, and for these the remaining bits at a line are used. The
   maxwidth field should be corrected for loading.


3.6  Critter animations

   Critter animations are stored in the folder "crit". The file "assoc.anm"
   holds data for each of the 32 animations and for the 64 NPC types. The file
   starts with 8 bytes for the name of each animation. Shorter strings are
   padded with zeros. Empty strings denote animations not available (in
   the "uw_demo").

   Next comes a table of infos for each NPC. The table is 64 entries (0x0080)
   long:

   0000   Int8   anim
   0001   Int8   auxpal

   The "anim" field specifies which one of the 32 animations to take for a
   given NPC number (NPC object ID - 0x0040).

   The "auxpal" value describes which auxiliary palette to use. There are
   several critters that share the same animations but use different palettes,
   e.g. the bat and the vampire bat uses the same anim value, but different
   auxiliary palettes.

   Animation for each critter is stored in a file like "CrXXpage.nYY", where
      XX = animation number (=anim), YY = page number
      XX and YY are octal numbers

   There may be more than one page for each animation file.
   The file starts with a header:

   pos     length          desc.
   0000    Int8            anim slot base
   0001    Int8            number of anim slots (=nslot)
   0002    nslot*Int8      list of segment indices

   After this, a list of segment follows which contains up to 8 frame indices
   for every segment.

   nslot+2 Int8            number of anim segments (=nsegs)
           8*nsegs         anim frame indices

   Then the auxiliary palettes follow:

           Int8            number of aux palettes (=npals)
           npals*32        allaux palette indices in blocks of 32

   Next is a list of all frames and their offsets into the file:

           Int8            number of frame offsets (=noffsets)
           Int8            compression type? (always 06)
           noffsets*Int16  absolute offsets to frame headers

   Each animation is stored in a segment which can contain a number of
   frames (stored in the "animation frame indices"). Each list is padded with
   0xFF entries.

   frame header

   0000    Int8       width
   0001    Int8       height
   0002    Int8       hotspot x
   0003    Int8       hotspot y
   0004    Int8       compression type; (06: 5-bit word size)
   0005    Int16      data length in number of words
   0007               start of rle-encoded image data (see 2.3)

   The hotspot coordinates are to "pin" the image at a specific position. The
   hotspot coordinates in the image should always be on the same place when
   rendered. The compression type can be 06, which is 5-bit run-length
   encoding, or 08, which is 4-bit run-length encoding (see 2.3. for more).

   The Slot lists group together segments of animations for various actions.
   Here's a list of slots and their actions:

      slot   action
       00    combat idle
       01    attack, bash (?)
       02    attack, slash (?)
       03    attack, thrust
       05    second weapon attach
       07    walking / running towards player
       0c    death
       0d    ??

       20    idle, facing away from player (180 degrees)
       21    idle, 135 deg.
       22    idle, angle 90 deg.
       23    idle, angle 45 deg.
       24    idle, facing towards player, 0 deg.
       25    idle, angle -45 deg.
       26    idle, angle -90 deg.
       27    idle, angle -135 deg.

   Segment indices at 80-87 are the same as above, except that these are the
   walking animations. For the animations used in the Ethereal Void (level 9)
   the slot list is somewhat different.

   Here is a list of animation files and their contents:

      file   assoc name   auxpals   used in
      cr00 * "gngob32"    4         green goblin
      cr01   "skela"      1         skeleton
      cr02   "lizman"     3         green, red and gray lizardman
      cr03 * "bat"        3         cave bat, vampire bat
      cr04   "wiza"       5         yellow male mage
      cr05 * "spider"     3         giant, wolf, dread spider
      cr06   "gazer"      1         gazer
      cr07   "troll"      3         troll, fereal troll, great troll
      cr10   "femwiz"     4         female mage
      cr11 * "slug"       2         flesh slug, acid slug
      cr12   "fire"       2         fire elemental
      cr13   "ghoul"      3         ghoul, dark ghoul
      cr14   "demon"      1         Slasher of the Veils
      cr15 * "ghost"      4         ghost, dire ghost
      cr16 * "graygob"    2         gray goblin
      cr17   "reaper"     1         reaper
      cr20 * "rat"        2         giant rat
      cr21   "femfite"    3         female fighter
      cr22 * "imp"        2         imp, mongbat
      cr23   "golem"      3         earth, stone and metal golem
      cr24 * "hedless"    1         headless
      cr25   "wizb"       3         blue female mage
      cr26 * "rotgrub"    2         green rotworm, bloodworm
      cr27   "wisp"       1         wisp
      cr30   "batskull"   2         bat, teeth, vortex, hound (level 9)
      cr31 * "Lurk"       2         lurker, deep lurker
      cr32 * "fight32"    4         male fighter, outcast, adventurer
      cr33   "dwarf32"    3         mountainman
      cr34   "shadow"     2         shadow beast
      cr35   "tybal"      1         tyball
      cr36   "eye"        1         eye, skull (level 9)
      cr37   "litening"   1         lightning, fish (level 9)

   The animations marked with * are available in the uw_demo, too.


3.7  Cutscene animations

   Cutscene animations are stored in folder "cuts". Text strings for cutscenes
   can be found in string blocks 0c00 through 0c21. Chapter 2.2.1 lists all
   animations available in Ultima Underworld 1.

   The cutscene files are done with Amiga's DeluxePaint Animator (file
   extension *.anm). The complete description can be found in the zip file
   "anmformt.zip" in the "misc" folder. Here's a short overview for usage in
   Ultima Underworld 1:

   The files, "large page files", consist of a header, followed by one or
   more large pages, where each page can store one or more animation frames.
   A large page is always 64k big, except for the last page (which is
   truncated at the end of usable data).

   The file starts with a "large page file header":

      0000   Int32   file ID, always contains "LPF "
      ...
      0006   Int16   number of large pages in the file
      0008   Int32   number of records in the file
      ...
      0010   Int32   content type, always contains "ANIM"
      0014   Int16   width in pixels
      0016   Int16   height in pixels

   The whole header is 128 bytes long. After the header color cycling info
   follows (which also is 128 bytes long), which is not used in uw1. Then
   comes the color palette:

      0000   Int8    intensity for blue, ranges from 0..255
      0001   Int8    intensity for green
      0002   Int8    intensity for red
      0003   Int8    padding byte
      ...            repeated for all 256 color indices

   After the palette an array with 256 "large page descriptors" follow:

      0000   Int16   number of first record in the large page
      0002   Int16   number of records in the large page
      0004   Int16   total number of bytes, excluding header

   Unused descriptors contain no information. After the array, the large pages
   start. A "large page" has the following layout:

      0000   lpdesc  large page descriptor
      0006   Int16   empty
      0008   Int16   length of first record
      000A   Int16   length of second record
      ...

   The large page descriptor is repeated for the current large page. A record
   contains a frame (which may depend on the previous frame). The start can be
   calculated by summing up the length of the previous records. A "record" has
   the following structure:

      0000   Int8    unknown
      0001   Int8    flag
      0002   Int16   extra offset, when flag != 0
      0004           start of compressed data

   The extra offset must be even (when odd, add an extra 1).

   The compression scheme is a variation of run-length encoding, with some
   extras. There are "dump", "run" and "skip" records. "dump" records just
   copy the next bytes to the output buffer. "run" records get the next byte
   and repeat them according to the count. A "skip" record skips pixels in the
   output buffer (it is assumed that the previous decoded image is still in
   the buffer).

   First, read a signed Int8. If it is positive, dump that many bytes.
   If it is 0, the next two Int8's are the count and the pixel byte for a
   "run" record. For negative values, remove the sign bit. If the resulting
   byte is != 0, skip that many bytes in the output, else a "long" operation
   is started.

   For the long operation, retrieve the next two Int8's, treating as a little
   endian signed Int16. If the value is 0, the decoding ends. If the value
   is > 0, skip that many bytes in the output. For values < 0, remove the sign
   bit. If the resulting value is >= 0x4000, we have a "run" record with
   count = value & 0x3fff and the next Int8 as the pixel index. If the value
   is <= 0x4000, we have a long "dump" record.

   Here is some C code to describe the decoding:

      while(true)
      {
         Int8 cnt = get_next_src8();

         if (cnt>0) dump_pixels(cnt);
         if (cnt==0) run_pixels(get_next_src8(),get_next_src8());
         if (cnt<0)
         {
            cnt &= 0x7f;
            if (cnt!=0) skip_pixels(cnt);
            else
            {
               // we have a "long" operation
               Int8 cnt2 = get_next_src16();
               if (cnt2>0)
                  skip_pixels(cnt2);
               else
               if (cnt2==0)
                  break;
               else
               {
                  cnt2 &= 0x7fff;

                  if (cnt2>=0x4000)
                     run_pixels(cnt2-0x4000,get_next_src());
                  else
                     dump_pixels(cnt2);
               }
            }
         }
      }

 +--------------------------------------------------------------------------+


6  Objects and items

   This chapter contains informations about the objects in Ultima Underworld.
   Objects (or items) are grouped by type. Here's a short overview of all
   object groups:

   0000-001F  Weapons and missiles
   0020-003F  Armour and clothing
   0040-007F  Monsters
   0080-008F  Containers
   0090-0097  Light sources
   0098-009F  Wands
   00A0-00AF  Treasure
   00B0-00BF  Comestibles
   00C0-00DF  Scenery and junk
   00E0-00FF  Runes and bits of the Key of Infinity
   0100-010F  Keys, lockpick, lock
   0110-011F  Quest items
   0120-012F  Inventory items, misc stuff
   0130-013F  Books and scrolls
   0140-014F  Doors
   0150-015F  Furniture
   0160-016F  Pillar, some decals, force field, special tmap (?)
   0170-017F  Switches
   0180-019F  Traps
   01A0-01BF  Triggers
   01C0-01CF  Explosions/splats, fountain, silver tree, moving things

   A description string for each object is stored in game strings block 0004


6.1  List of all objects and items

   This chapter lists and describes all objects that are available in Ultima
   Underworld. Descriptions for obvious items are omitted.

   000f: a_fist
         this is not really an item, but is used for fist combat

   002f  a_pair of dragon skin boots
         player doesn't get hurt when walking on lava

   007f  an_adventurer
         the player as object; isn't used ingame

   0110  a_picture of Tom

   0166  some_writing
         decal on the wall; text is determined through "quantity" field,
         first 10 bits; game strings block 0008


6.1.2  Traps and Triggers

   Traps are set off by triggers, which are triggered by the player coming
   near them. Traps can also be set off by switches or buttons, etc.

   0180  a_damage trap
         player is hurt; number of hit points are in field "quality"

   0181  a_teleport trap
         teleports the player to another level and tile; destination level is
         given by trap z position (0 means current level), tile coordinates
         are given in "quality" and "owner" fields.

   0182  a_arrow trap
   0183  a_do trap
   0184  a_pit trap
   0185  a_change terrain trap
   0186  a_spelltrap
   0187  a_create object trap
   0188  a_door trap
         opens or shuts a door when set off. The "quantity" field specifies
         the lock of the door.

   0189  a_ward trap
   018a  a_tell trap
   018b  a_delete object trap
   018c  an_inventory trap
   018d  a_set variable trap
   018e  a_check variable trap
   018f  a_combination trap
   0190  a_text string trap
         causes the player to get a text message when it is set off. The
         "owner" field specifies string number per level, in game strings
         block 0009. The actual string number printed is (64*level + "owner")

   01a0  a_move trigger
   01a1  a_pick up trigger
   01a2  a_use trigger
         triggers a trap as if it was "used" by the player. trap to use is
         specified in "quantity" field.

   01a3  a_look trigger
   01a4  a_step on trigger
   01a5  an_open trigger
   01a6  an_unlock trigger


6.2  Common object properties

   Object properties common to all items are stored in the file "comobj.dat".
   The number of object properties is determined by (filelen-2) / 11   (each
   entry is 11 bytes long).

   The first two bytes of the file contain unknown information. Each entry has
   the following format:

   0000  Int8    armour (ID?)
   0001  Int16   mass/stuff:
                 bits 0-3:  unknown
                 bits 4-15: mass in 0.1 stones
   0003  Int8    flags (lower 4 bits only)
                 0/2: object in range [336, 368[ seem to be 3d objects
                 4:   decal object
   0004  Int16   value (?)
   0005  Int24   unknown1
   0008  Int8    scale value (?)
   0009  Int8    unknown2
   000A  Int8    lower 4 bits are quality type 0-f

   Each possible value of "quality type" maps onto a group of 6 strings in
   block 4 from lowest to highest quality. Items which have a quality are
   always described as "a/an <quality> <item>", with the exception of group D
   which is for armour items which are gramatically plural even if there is
   only one of the object, e.g. "leather leggings".


6.3  Object class properties

   Object properties specific to a range of objects are stored in the file
   "objects.dat". The file contains several tables. Here is an overview:

   pos   size     desc                        entries   bytes per entry
   0000  Int16    unknown, always 0x010f
   0002  0x80     melee weapons table         16         8 bytes
   0082  0x30     ranged weapons table        16         3 bytes
   00b2  0x80     armour and wearables table  32         4 bytes
   0132  0x0c00   critters table              64        48 bytes
   0d32  0x30     containers table            16         3 bytes
   0d62  0x20     lights info table           16         2 bytes
   0d82  0x20     unknown, maybe jewelry info table
   0da2  0x40     animation object table      16         4 bytes
   0de2           end

   * Melee weapons table

   0000   Int8   damage modifier for Slash attack
   0001   Int8   damage modifier for Bash attack
   0002   Int8   damage modifier for Stab attack
   0003   3      unknown
   0006   Int8   skill type (3: sword, 4: axe, 5: mace, 6: unarmed)
   0007   Int8   durability

   * Ranged weapons table

   0000   Int8   unknown
   0001   Int8   unknown
   0002   Int8   durability

   * Armour and wearables table

   0000   Int8   protection
   0001   Int8   durability
   0002   Int8   unknown
   0003   Int8   category:
                 00: shield
                 01: body armour
                 03: leggings
                 04: gloves
                 05: boots
                 08: hat
                 09: ring

   * Critters table

   0000   Int8   unknown

   * Containers table

   0000   Int8   capacity
   0001   Int8   objects accepted (0xFF means any)
   0002   Int8   unknown

   * Lights info table

   0000   Int8   light brightneess
   0001   Int8   duration (00: does't go out, e.g. taper of sacrifice)

   * Jewelry info table (?)

   * Animation object table

   0000   Int8   unknown
   0001   Int8   start frame (from animo.gr)
   0002   Int8   number of frames
   0003   Int8   unknown


6.4  Item combining

   In the Ultima Underworlds, when you `apply' certain objects to one another
   in your inventory a new object is created. For example,
   pole + strong thread = fishing pole. The mechanism for this is very simple
   and is controlled by the file "cmb.dat" in the data/ directory.

   This file contains a table of 3 16-bit words for each allowable
   combination: `source1', `source2', `newobject' in that order. 3 zeros mark
   the end of the table. The low 9 bits of each word is the object ID. If an
   object of type source1 is applied to an object of type source2 (or vice
   versa) an object of type newobject is created. The top bit of each of the
   source words indicates whether that object is destroyed in the process: if
   it is a 1, the object is destroyed. (It is always the case that at least
   one of the source objects is destroyed: you can't create something from
   nothing, at least not this way).


 +--------------------------------------------------------------------------+


+--------------------------+
+ old document starts here +
+--------------------------+

Ultima Underworld Formats Specification
---------------------------------------


Table of Contents

1.0   General stuff
1.1   Summary of data files

2.0   Level Map File
2.1   Palettes
2.2   Textures
2.3   Graphics
2.4   Fonts
2.5   Bitmaps
2.6   Palette mappings

3.0   Object IDs
3.1   Common object properties
3.2   Object class properties
3.3   Traps

4.0   Game strings
4.1   Conversations

5.0   Critter Animation
5.1   Cutscene Animations

6.0   Savegame format

7.0   3D object models

8.0   Misc. stuff
8.1   Combining objects
8.2   Graves
8.3   Terrain texture properties


1.0 General stuff

   In this document, all integers are refered as Int8, Int16 or Int32,
   depending on their number of bits.

   All files from Ultima Underworld are in little endian format, that means
   that the low-byte of an Int16 intever comes first in the file, and is
   followed by the high-byte.

   Most of the stuff in this file is from the original "uw-specs.txt" found
   in "The System Shock Hack Project". System Shock uses almost the same
   data structures for the game. Many thanks to Jim Cameron!

   Copyright (c) 2000,2001,2002 Jim Cameron
   Copyright (c) 2002 Michael Fink

   Additional information from:

   Fabian Pache
     - map details, UW2 related
     - 3D models, UW2 related

   Alistair Brown (basic object format, via the Underworld II editor
      <http://bearcity.pwp.blueyonder.co.uk/>)

   Ulf Wohlers (Objects and 3D models)




2.0 Level Map File

   Level maps are stored in file "lev.ark". The header of the file contains
   the offsets to all the chunks in the level archive. First there is a Int16
   value giving the number of chunk directory entries (0x0087 = 135 for 9x15
   possible chunks) followed by Int32 offset for each chunk (measured from the
   start of the file).

   Chunks are arranged in blocks of 9 (Ultima Underworld 1 has 9 levels, Abyss
   levels 1 - 8 and the Ethereal Void). There is space in the header for 15
   such blocks, though only 5 are actually used.

   When the offset is a value of 0, the chunk or block is not available and
   contains no data. There are 45 offsets which point to different data:

   <9 blocks level map/object info>
   <9 blocks object animation overlay info>
   <9 blocks level texture usage>
   <9 blocks level automap flags>
   <9 blocks level comment entries>

2.0.1 Level map info

   The level map chunk for each level contains information about the level
   architecture (tile map) and the objects which live in it:

    Offset  Size   Description
    0000    4000   Tile map (64 x 64 x 4 bytes)
    4000    1b00   Mobile object information (objects 000-0ff, 256 x 27 bytes)
    5b00    1800   Static object information (objects 100-3ff, 768 x 8 bytes)
    7300    01fc   Free list for mobile objects (objects 002-0ff, 254 x 2 bytes)
    74fc    0600   Free list for static objects (objects 100-3ff, 768 x 2 bytes)
    7afc    0104   Unknown (260 bytes)
    7c00    0002
    7c02    0002   No. entries in mobile free list minus 1
    7c04    0002   No. entries in static free list minus 1
    7c06    0002   0x7775 ('uw')

   Tile map
   --------
   Levels are always 64 x 64 tiles. Map origin is at the lower left tile,
   going to the right, each line in turn. For each tile there are two Int16
   values stored. The two values can be split into bits:

   00 tile properties / flags:

      bits      len  description
       0 -  3    4   tile type (0-9, see below)
       4 -  7    4   floor height
       8 -  9    2   ?? special light feature ??
      10 - 13    4   floor texture index (from level texture usage block)
      14         1   unknown (only used on level 6, near the shrine)
      15         1   door bit (when 1, a door is present)

      about bit 8,9:
      They have me hitting my head against the wall. Bit 9 is never set, so
      it can be gladly ignored. For UW2 Bit 8 is set pretty often, and if
      set the light level changes. Ironically 1 sometimes means daylight (in
      Lord British Castle Lv 1) but sometimes 0 means daylight (LBC Lv 5).
      But the areas are exactly right.

   02 tile properties 2 / object list link

      bits      len  description
       0 -  5    6   wall texture index (from level texture usage)
       6 - 15   10   first object in tile (index into master object list)

   Underworld tile types are:
    00      Solid (wall tile)
    01      Open (square tile of empty space)
    02      Diagonal, open SE
    03      Diagonal, open SW
    04      Diagonal, open NE
    05      Diagonal, open NW
    06      Sloping up to the north
    07      Sloping up to the south
    08      Sloping up to the east
    09      Sloping up to the west

   Mobile / Static object info
   ---------------------------
   The master object list is stored after the map data. There are 1024
   entries (0x400) in the table. The first 256 entries contain infos about
   mobile objects (NPCs, critters) and have 8 + 19 bytes each.

   0000   Int16*4   general object infos
   0008   19        mobile object extra infos (see below)

   The reamaining 768 object entries starting at 0x100 only have general
   object infos and are 8 bytes long each.

   General object infos
   --------------------
   They contain 4 Int16 words which can be split into bits:

   00 objid / flags:      0- 8   Object ID (see below)
                          9-15   Flags
                            12   Enchantment flag (enchantable objects only)
                            14   Set only for traps, triggers and locks -
                                 "Effects The World Flag?"
                            15   Link flag (link field is quantity/special)

   02 position:           0- 6   Object Z position (0-127)
                          7- 9   Heading (*45 deg)
                          10-12  Object Y position (0-7)
                          13-15  Object X position (0-7)

   04 quality / chain:    0- 5   Quality
                          6-15   Index of next object in chain

   06 link / special:     0- 5   Owner / special
                          6-15   Quantity / link / special property

   Object chaining
   ---------------
   Objects in a tile are stored as a linked list, where the "Index of next
   object in chain" points to the next object in list, or contains 0 for the
   end of the linked list. The first object in the list is determined by the
   tile's object index value (see above, at "Tile map").

   For normal objects, the "Owner" field describes the NPC type the object
   belongs to. NPC object ID = Owner - 1 + 0x0040. When the field is 0, the
   object doesn't belong to anyone.

   Link Field
   -----------
   The link field can be used for various things. If the link flag is unset,
   it contains the index of an associated object. The exact meaning varies,
   but is generally a "has-a" type relationship (contents, trap to set off,
   spell).

   If the link flag is set, this field is a quantity or special property.
   Quantity is straightforward; if the value is less than 512 it gives the
   number of a stackable item that are present in the stack, so identical
   items may be combined into one object definition.

   Quantities >= 512 are special properties. The value is the link field
   minus 512 (unsurprisingly), the meaning depends on object type and flags.

   Flags
   -----
   For item 0x164 (a_bridge) the "flags" value specifies the bridge texture
   number to use. For item 0x16e (special tmap obj) the decal to use comes
   from the "special" field.

   Enchantments
   ------------
   If the enchantment flag is set and the object is enchantable, then the
   link field (less 512) determines the enchantment. Enchantment names are
   stored in strings chunk 5. The way in which the link value maps onto
   spells in this chunk depends on the object type.

   Most objects seem to use spells 256-320 (add 256) if the enchantment
   number is in the range 0-63, otherwise they add 144 to use spells 208 and
   up. Healing fountains, however, don't use a correction at all.

   Weapons and armour have a more complex mapping. Most enchanted weapons and
   pieces of armour have an enhancement for Accuracy, Damage, Protection or
   Toughness, which are spells 448-479 in the main spell list. These map to
   special property values 192-207. Yes, there are only 16 values for 32
   spells; enchanted armour adds another 16 to the spell index to bring it
   into the armour enchantment range. However, these items may also carry
   generic enchantments, in which case the special properties map to spells
   0-255 (and armour doesn't apply a special correction).

   Wands don't hold their enchantments directly in the quantity field, since
   they also need to store the number of charges remaining. Instead, they
   link to a spell object which holds the enchantment; it seems here that
   the "quality" field of the spell object determines the number of charges.
   Other objects may also carry spells in this way.

   Links
   -----
   When the link field is a link (link flag NOT set), it links to another
   object(s). Here's a list of IDs and the link meanings:

    0040 - 007f: all sorts of NPCs (link points to inventory start)
    0080 - 008e: all sorts of container (points to content)
    008f: a_rune bag (specially treated)
    0098 - 009f,00aa: all sorts of wands (points to a "a_spell" object)
    0140 - 014f: doors (points to a "a_lock" object, when locked)
    015b, 015e: a_chest, a_barrel (3d objects)
    0161: a_lever (mostly points to "a_use trigger" object)
    016e: special tmap obj (?)
    0170 - 017f: button, switches etc. (points to "a_use trigger" object)
    0187: a_create object trap (points at object to create)
    0188: a_door trap (usually points to "a_lock" object)
    01a0: a_move trigger
    01a2: a_use trigger
    01a3: a_look trigger
    01a5: an_open trigger
    01a6: an_unlock trigger

   Mobile object extra infos
   -------------------------
   The infos are 19 bytes long each and can be split up like this:

      0000   Int8   npc_hp, npc hit points
      0001   Int8   unknown
      0002   Int8   unknown
      0003   Int8   unknown
      0004   Int8   unknown
      0005   Int8   unknown
      0006   Int8   flags:
                       bits 7-8: npc_attitude (string block 5, pos 96..99)
      0007   Int8   unknown
      0008   Int8   unknown
      0009   Int8   unknown
      000a   Int8   unknown
      000b   Int8   unknown
      000c   Int8   unknown
      000d   Int8   unknown
      000e   Int16  npc home coordinates:
                       bits 0-3:   unknown
                       bits 4-9:   npc_yhome
                       bits 10-15: npc_xhome
      0010   Int8   unknown
      0011   Int8   unknown
      0012   Int8   npc_whoami, conversation slot to use (or 0 for none)

   The conversation slot to use is  npc_whoami + 0x0e00. If the value is 0,
   a generic conversation is used, starting from string blocks 0x0f00.

   Free list, mobile objects
   -------------------------
   This consists of an Int16 for each mobile object (critter) slot which is
   not in use, giving the slot position in the master object list. Note that
   there are only 254 entries in this table because object 0 is always the
   null object (and hence is never allocated) and object 1 is always the
   avatar (and can never be free - that's probably a metaphor for life, or
   something). Of course, only the first (no. free mobile objects) entries
   are valid.

   Free list, static objects
   -------------------------
   This consists of an Int16 for each static object which is not in use, as
   above. This table is 768 entries long (room for all possible static objects).

2.0.2 Object animation overlay info

   The 9 blocks contain entries with length of 6 bytes with infos about
   objects with animation overlay images from "animo.gr".
   It always is 0x0180 bytes long which leads to 64 entries.

   0000   Int16   link1
   0002   Int16   unk2
   0004   Int8    tile x coordinate
   0005   Int8    tile y coordinate

   link1's most significant 10 bits contain a link into the object table,
   to the object that should get an animation overlay.

2.0.3 Level texture usage

   0000  48 x Int16   wall texture number (from w64.tr)
   0030  10 x Int16   floor texture number (from f32.tr)
   003a   6 x Int16   door decal number (from doors.gr (?))

   The last value from the floor texture number array is used as ceiling
   texture.

2.0.4 Level automap flags

   each block contains the "visited" bytes for each level. Each byte
   describes a tile on the main map. The block size always is 0x1000.

2.0.5 Level comment entries

   not decoded yet

2.0.6 Underworld 2 differences

   The file "lev.ark" has a silightly different format here:

     0000  Int16  number of chunks in file (0x0140 = 320)
     0004  Int32  unknown

   Now follow 4 tables, each for the number of directory entries
   every table entry is a Int32

     Table 1: offset table
       number of bytes from bof to datachunk.
       an offset of 0 means the entry is not (yet) used

     Table 2: flags for the datachunk
       Bit 0 is always set
       Bit 1 is set for compressed entries
       Bit 2 is set for entries where data size is not maxsize,
             might be chunks that are writen to when the game is saved

     Table 3: data size
       either compressed or uncompressed data, according to the flags

     Table 4: maxsize
       this is mainly a guess
       maxsize is always greater or equal to data size.
       If it is greater the exess bytes are zeros

     there are 320 entries in the standard lev.ark
     these can be split into 4 sets of 80 entries each
       0.. 79  level maps
      80..159  texture mappings
     160..239  map visibility flags
     240..319  ??? strings, entered on map ???

   * Level maps

     as described in 2.0

   * Texture mappings

     these are 134 Bytes large, either uncompressed or after decompression
     each of the 64 entries is an Int16, the index of the texture in t64.tr
     the first 16 entries are shared by the floor and wall indices
     entries 17 to 63 are wall-only textures
     ceiling seems to be textured by entry 0x20

     the last 6 bytes appear to be some kind of checksum, always 00 01 02 03 04 05 


3.3 Traps

   Traps have various effects on the game world. Traps have object IDs from
   0x0180 to 0x0190

   0180  Damage trap
   0181  Teleport trap
   0182  Arrow trap
   0183  "Do" trap
   0184  Pit trap
   0185  Change terrain trap
   0186  Spell trap
   0187  Create object trap
   0188  Door trap
   0189  Ward trap
   018A  "Tell" trap
   018B  Delete object trap
   018C  Inventory trap
   018D  Set variable trap
   018E  Check variable trap
   018F  Combination trap
   0190  Text string trap
   0192  Jump trap (uw2)


   * Pit trap (ID 0184)

     This is probably a bottomless pit that drops the player through to the
     next level.

     (uw2) This is a special effect trap, that triggers 'visual' effects like
     earthquakes, or blurry vision. In UW2, 'pits' are interpreted in terms
     of teleport traps in all cases.

   * Create object trap (ID 0187)

     This trap creates an object when it is set off. The link field
     points at the object to create.

   * Jump trap (ID 0192) (uw2)

     Causes the player to get an upward velocity according to the quality
     field; where '24' would be the velocity one would get from a standing
     jump.


4.0 Game strings

   Game strings are stored in the file "strings.pak", and uses a Huffman
   compression scheme to store its strings. The first 2 bytes of the file give
   the number of nodes in the tree. Then follow the nodes themselves, 4 bytes
   each:

   0000   Int8   char symbol
   0001   Int8   parent node
   0002   Int8   left child
   0003   Int8   right child

   The last node stored in the file is the head of the tree. Following the
   nodes is a 16-bit word giving the number of string blocks in the
   file. Then follows the block directory, 6 bytes per block as follows:

   0000   Int16   block number
   0002   Int32   offset in file of start of block

   Each block contains a variable number of strings. The block header is:

   0000   Int16   no. of strings
   0002   Int16   relative offset from end of block header to first string
   0004   Int16   relative offset to second string
   ...

   Strings are compressed using the Huffman tree in the usual way. Bits are
   extracted big-endian i.e. rotated out of the top of each byte in turn.
   Starting with the root node (last node), if a 1 bit is encountered the right
   branch is taken, otherwise take the left. Repeat until a leaf (node with -1
   for its children) is reached, at which point output the symbol for that node.
   For the next bit we start again from the root. End of string is marked with a
   `|' character. The remaining bits in the last byte are unused.

   * game strings contents

     block 0001: general UI strings
     block 0002: character creation strings, mantras (?)
     block 0003: wall text/scroll/book/book title strings (*)
     block 0004: object descriptions (*)
     block 0005: object "look" descriptions, object quality states
     block 0006: spell names
     block 0007: conversation partner names, starting at string 17 for conv 1
     block 0008: text on walls, signs
     block 0009: text trap messages
     block 000a: wall/floor description text
     block 0018: debugging strings (not used ingame)
     block 0c00: intro cutscene text
     block 0c01: ending cutscene text
     block 0c02: tyball cutscene text
     block 0c03: arial cuscene text (?)
     block 0c18: dream cutscene 1 text "arrived"
     block 0c19: dream cutscene 2 text "talismans"
     block 0c1a-0c21: garamon cutscene texts
     block 0e01-0f3a: conversation strings

     Block 0003 contains text/scroll etc. strings. The exact string to use for
     books, scrolls or other text object is in the link2 field. It is calculated
     as link2 - 0x0200. For each level, 32 string slots are available.

     Block 0004 contains the object descriptions. The article (e.g. 'a' or
     'an') is separated with an underscore '_'. When a '&' is in the string,
     it separates the plural of the object's name. The complete text string is
     "you see <article> <mood> <description> [named <npc-name>]. <mood> can be
     one of "mellow" or "upset".

     In the uw_demo, the 0cXX blocks and many of the conversation string
     blocks aren't available.


4.1 Conversations

   Conversations are stored in the file "cnv.ark". File header:

   0000   Int16   number of conversation slots in file
   0002   Int32   offset to conversation slot #0
   ...

   If an offset is 0, the conversation slot is empty and no conversation is
   available. The name of the conversation partner is stored in string block
   0007, as string number (conversation slot number - 0x0e00 +16).

   The conversation header looks like this:

   0000   Int32   unknown1, always seems to be 0x0828, or 28 08
   0004   Int32   code size in number of instructions (16-bit words)
   0008   Int16   unknown2, always seems to be 0x0000
   000A   Int16   game strings block to use
   000C   Int16   number of memory reserved for variables (*)
   000E   Int16   number of imported globals (functions + variables)
   0010           start of imported functions list

   (*) This number includes all variables not belonging to stack, e.g. unnamed
   globals, imported globals and private conversation globals.

   An import record describes imported functions and game global variables
   used by the conversation:

   0000   Int16   length of function name
   0002   n*char  name of function
   n+02   Int16   ID (imported func.) / memory address (variable)
   n+04   Int16   unknown, always seems to be 1
   n+06   Int16   import type (0x010F=variable, 0x0111=imported func.)
   n+08   Int16   return type (0x0000=void, 0x0129=int, 0x012B=string)

   After this table the code section follows.

   Each conversation has a set of private global variables that are saved
   across conversations. The initial size of them are stored in the file
   "babglobals.dat". When a game is saved, the globals are stored in the file
   "bglobals.dat". The layout of both files is as follows:

   0000   Int16     number of conversation slot
   0002   Int16     size of private global data for that conv.
   0004   n*Int16   all globals for that slot (omitted in "babglobals.dat")
   ...              repeat until file end

   On conversation start the game globals listed in the import table is
   copied to the memory address in the private globals. At end of conversation
   they are copied back to the game globals.

   * Memory layout

     0000    unnamed globals (may be empty, size nglobals)
     000n    imported globals (copied on start) (usually 0x001f long)
     0020    private conversation globals (of size nprivglobals)
     0020+n  stack begin (ascends up)

     There may be unnamed globals that start at memory location 0. The
     imported globals then start at a higher address (the exact positions
     of the imported globals are noted in the "import records list".

     For the memory, a full range of 16-bit memory (64k) should be available,
     which gives plenty of stack memory.

   * Conversation assembler language

   The conversation code is an assembler-like languages with a set of opcodes.
   It runs on a 16-bit virtual machine with a stack and a result register for
   imported functions. The language set is described here:

   Opcode         no. immediate operands
   |   Name       | no. stack operands
   |   |          | | No. values saved to stack
   |   |          | | |  Action
   |   |          | | |  |
   00  NOP        0 0 0  do nothing.
   01  OPADD      0 2 1  push s[0] + s[1]
   02  OPMUL      0 2 1  push s[0] * s[1]
   03  OPSUB      0 2 1  push s[1] - s[0]
   04  OPDIV      0 2 1  push s[1] / s[0]
   05  OPMOD      0 2 1  push s[1] % s[0]
   06  OPOR       0 2 1  logical OR of top two values.
   07  OPAND      0 2 1  logical AND of top two values.
   08  OPNOT      0 1 1  logical NOT of top value.
   09  TSTGT      0 2 1  greater-than, nonzero if s[1] > s[0].
   0A  TSTGE      0 2 1  greater-than-or-equal.
   0B  TSTLT      0 2 1  less-than.
   0C  TSTLE      0 2 1  less-than-or-equal.
   0D  TSTEQ      0 2 1  equality. Nonzero if s[1] == s[0].
   0E  TSTNE      0 2 1  non-equal.
   0F  JMP        1 0 0  jump absolute. address is measured in words from the
                         start of the code.
   10  BEQ        1 1 0  branch on equal. Pop a value, branch relative if zero.
   11  BNE        1 1 0  branch on Not Equal. As BEQ but branch if the value
                         popped is non-zero.
   12  BRA        1 0 0  branch. Always branch relative to the offset address.
   13  CALL       1 0 1  call subroutine. Push the next instruction address and
                         jump to the absolute address (in words) given.
   14  CALLI      1 0 0  call imported subroutine. Argument is the function ID.
   15  RET        0 1 0  return from subroutine. Pop the return address off the
                         stack and jump to it.
   16  PUSHI      1 0 1  push immediate value onto the stack.
   17  PUSHI_EFF  1 0 1  push effective address onto the stack. The value
                         pushed is the current frame pointer address plus the
                         immediate operand. This allows local variables and
                         function parameters.
   18  POP        0 1 0  pop a value from the stack (and throw it away).
   19  SWAP       0 2 2  swap the top two stack values.
   1A  PUSHBP     0 0 1  push the current frame pointer onto the stack.
   1B  POPBP      0 1 0  pop the frame pointer from the stack
   1C  SPTOBP     0 0 0  new frame. Set the frame pointer to the stack pointer.
   1D  BPTOSP     0 0 0  exit frame. Set the stack pointer to the frame pointer.
   1E  ADDSP      0 1 *  pop a value, add to the stack pointer. Used
                         to reserve stack space for variables.
   1F  FETCHM     0 1 1  pop address, push the value of the variable pointed to.
   20  STO        0 2 0  store s[0] in the variable pointed to by s[1].
   21  OFFSET     0 2 1  array offset. Add s[1] - 1 to the effective address in
                         s[0], push this as a new effective address.
   22  START      0 0 0  start program.
   23  SAVE_REG   0 1 0  pop a value from the stack and store it in the result
                         register.
   24  PUSH_REG   0 0 1  push the value of the result register on the stack.
   25  STRCMP     ? ? ?  string compare.
   26  EXIT_OP    0 0 0  end program (?)
   27  SAY_OP     0 1 0  NPC says something. Print a conversation string (from
                         the stack).
   28  RESPOND_OP ? ? ?  respond (?)
   29  OPNEG      0 1 1  negate. s[0] -> -s[0].

   (*) ADDSP, of course, doesn't actually push anything onto the stack, but its
       effect on the stack pointer is of pushing as many values as its operand
       specifies.
   (?) I haven't yet encountered these in the wild, so don't know exactly what
       they do.

   * Conversation text substitutions

     In text strings printed by SAY_OP or a imported function (like
     "babl_menu") there may be strings like @SS1 or @GS8 that are substituted
     with other text. The format of the "format string" is like this:

     @XY<num>[<extension>]

     X: source of variable to substitute, one of these: GSP
        G: game global variable
        S: stack variable
        P: pointer variable
     Y: type of variable, one of these: SI
        S: value is a string number into current string block
        I: value is an integer value
     <num>: decimal value
     <extension>: format: C<number>, might be fractional part

     For pointer variables, the num value determines the location of the
     pointer relative to the stack. It usually refers to variables passed
     to a function (since they were push'ed onto the stack).

     For stack variables, the num value determines which stack value is taken
     from the current local variables. The value to take is basep + <num>

     For global variables, the value describes the globals position in memory,
     at the front where the imported game globals and private globals are
     stored.

     Example:
     @SS2 means: print string with string number found at basep + 2
     @PI-3 means: print int value pointed to by pointer at basep - 3
     @GS8 means: print string from global var #8

   * Conversation imported functions

     Each imported function has an ID (the argument of the CALLI opcode), and
     the "import table" (see above) usually imports all available functions,
     even unused ones. All imported functions have at least one argument, and
     the first one is the number of arguments additionally passed (some times
     this rule seems to be violated, e.g. function "babl_menu", see (*)
     below). First argument is always pushed last on stack. All values are
     passed by reference.

     Here is a quick overview of all builtin functions ("args" is the number
     of arguments without the mandatory first one):

      type    args     function name
      int      1 (*)   babl_menu
      int      2 (*)   babl_fmenu
      void     1       print
      int      0       babl_ask
      int      2       compare
      int      1       random
      string   ?       plural
      int      2       contains
      string   ?       append
      string   ?       copy
      int      ?       find
      int      1       length
      int      ?       val
      void     ?       say
      void     ?       respond
      int      1       get_quest
      void     2       set_quest
      string   2       sex
      int      2       show_inv
      int      2       give_to_npc
      int      2       give_ptr_npc
      int      1       take_from_npc
      int      1       take_id_from_npc
      int      4       identify_inv
      int      *       do_offer
      int      2       do_demand
      int      1       do_inv_create
      int      1       do_inv_delete
      int      1       check_inv_quality
      int      2       set_inv_quality
      int      1       count_inv
      void     0       setup_to_barter
      void     ?       end_barter
      void     0       do_judgement
      void     0       do_decline
      void     ?       pause
      void     2       set_likes_dislikes
      int      3       gronk_door
      void     1/3     set_race_attitude
      void     3       place_object
      void     1       take_from_npc_inv
      void     ?       add_to_npc_inv
      void     0       remove_talker
      void     2       set_attitude
      int      2       x_skills
      int      2       x_traps
      void     ?       x_obj_pos
      void     9       x_obj_stuff
      int      2       find_inv
      int      1       find_barter
      int      4       find_barter_total

     Here is a detailed description of every builtin function. arg0 is always
     the first argument (the last value pushed on the stack) and specifies the
     number of arguments passed.

     id=0000 name="babl_menu" ret_type=int
     parameters:   arg1: pointer to a list of string id's; ends with id == 0
     description:  shows a menu of further questions the user can select;
                   string id's are stored in list in arg1
     return value: number of selected response (one-based index of arg1 list)
     -------------------------------------------------------------------------

     id=0001 name="babl_fmenu" ret_type=int
     parameters:   arg1: pointer to list of string id's; ends with id == 0
                   arg2: pointer to list with on/off values (1==on)
     description:  shows a menu with questions from list in arg1; the list in
                   arg2 indicates if the question is available (0 means not
                   available).
     return value: number of selected response string (from the arg1 list)
     -------------------------------------------------------------------------

     id=0002 name="print" ret_type=void
     parameters:   arg1: pointer to string id
     description:  prints a string that is not spoken by anyone (e.g. scene
                   description).
     -------------------------------------------------------------------------

     id=0003 name="babl_ask" ret_type=int
     parameters:   none
     description:  lets the user type in a string; the string typed in is
                   stored in a newly allocated string slot. The string is not
                   stored after conversation ended.
     return value: string handle of allocated string
     -------------------------------------------------------------------------

     id=0004 name="compare" ret_type=int
     parameters:   arg1: pointer to string handle
                   arg2: pointer to string handle
     description:  compares strings for equality, case independent
     return value: returns 1 when strings are equal, 0 when not
     -------------------------------------------------------------------------

     id=0005 name="random" ret_type=int
     parameters:   arg1: highest value
     description:  generates a random number in the range of [1..arg1]
     return value: the generated random number
     -------------------------------------------------------------------------

     id=0006 name="plural" ret_type=string
     parameters:   arg1: item id to retrieve plural string (guessed)
     description:  (as this function is not used in uw1, I only can guess)
                   the function returns a newly allocated string with the
                   plural of the description string of a given item id.
     return value: string handle (guessed)
     -------------------------------------------------------------------------

     id=0007 name="contains" ret_type=int
     parameters:   arg1: pointer to first string handle
                   arg2: pointer to second string handle
     description:  checks if the first string contains the second string
                   (case-independent).
     return value: returns 1 when the string was found
     -------------------------------------------------------------------------

     id=0008 name="append" ret_type=string
     parameters:   unknown
     description:  (not used in uw1)
     return value: unknown
     -------------------------------------------------------------------------

     id=0009 name="copy" ret_type=string
     parameters:   unknown
     description:  (not used in uw1)
     return value: unknown
     -------------------------------------------------------------------------

     id=000a name="find" ret_type=int
     parameters:   unknown
     description:  (not used in uw1)
     return value: unknown
     -------------------------------------------------------------------------

     id=000b name="length" ret_type=int
     parameters:   arg1: pointer to string handle
     description:  calculates length of string
     return value: returns length of string
     -------------------------------------------------------------------------

     id=000c name="val" ret_type=int
     parameters:   unknown
     description:  (not used in uw1)
     return value: unknown
     -------------------------------------------------------------------------

     id=000d name="say" ret_type=void
     parameters:   unknown
     description:  (not used in uw1)
     return value: unknown
     -------------------------------------------------------------------------

     id=000e name="respond" ret_type=void
     parameters:   unknown
     description:  (not used in uw1)
     return value: unknown
     -------------------------------------------------------------------------

     id=000f name="get_quest" ret_type=int
     parameters:   arg1: quest flag number
     description:  returns a quest flag value
     return value: quest flag value
     -------------------------------------------------------------------------

     id=0010 name="set_quest" ret_type=void
     parameters:   arg1: new flag value
                   arg2: quest flag number
     description:  sets a quest value
     return value: none
     -------------------------------------------------------------------------

     id=0011 name="sex" ret_type=string
     parameters:   arg1: pointer to first string handle
                   arg2: pointer to second string handle
     description:  decides on the gender of the avatar which string handle to
                   return. for a male avatar, the second handle is taken,
                   otherwise the first handle is taken
     return value: selected string handle
     -------------------------------------------------------------------------

     id=0012 name="show_inv" ret_type=int
     parameters:   arg1: unknown
                   arg2: unknown
     description:  lets the player show an item to the NPC, the player gets
                   the item back (?)
     return value: unknown
     -------------------------------------------------------------------------

     id=0013 name="give_to_npc" ret_type=int
     parameters:   arg1: item id
                   arg2: item quantity
     description:  
     return value: unknown, ignored
     -------------------------------------------------------------------------

     id=0014 name="give_ptr_npc" ret_type=int
     parameters:   arg1: quantity?
                   arg2: master object list position? (got from find_barter)
     description:  player hands over an item to NPC (?)
     return value: unused
     -------------------------------------------------------------------------

     id=0015 name="take_from_npc" ret_type=int
     parameters:   arg1: item id
     description:  gives the player an item
     return value: 1: ok, 2: player has no space left
     -------------------------------------------------------------------------

     id=0016 name="take_id_from_npc" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=0017 name="identify_inv" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=0018 name="do_offer" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=0019 name="do_demand" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=001a name="do_inv_create" ret_type=int
     parameters:   arg1: item id
     description:  creates item in npc inventory
     return value: unknown
     -------------------------------------------------------------------------

     id=001b name="do_inv_delete" ret_type=int
     parameters:   arg1: item id
     description:  deletes item in npc inventory
     return value: unknown
     -------------------------------------------------------------------------

     id=001c name="check_inv_quality" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=001d name="set_inv_quality" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=001e name="count_inv" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=001f name="setup_to_barter" ret_type=void
     parameters:   none
     description:  starts bartering
     -------------------------------------------------------------------------

     id=0020 name="end_barter" ret_type=void
     parameters:   unknown
     description:  (not used in uw1), ends bartering
     -------------------------------------------------------------------------

     id=0021 name="do_judgement" ret_type=void
     parameters:   none
     description:  judges current trade (using the "appraise" skill) and
                   prints result
     -------------------------------------------------------------------------

     id=0022 name="do_decline" ret_type=void
     parameters:   none
     description:  declines trade offer (?)
     -------------------------------------------------------------------------

     id=0023 name="pause" ret_type=void
     parameters:   unknown
     description:  (not used in uw1)
     -------------------------------------------------------------------------

     id=0024 name="set_likes_dislikes" ret_type=void
     parameters:   arg1: pointer to list of things the npc likes to trade
                   arg2: pointer to list of things the npc dislikes to trade
     description:  sets list of items that a npc likes or dislikes to trade;
                   the list is terminated with a -1 (0xffff) entry
     -------------------------------------------------------------------------

     id=0025 name="gronk_door" ret_type=int
     parameters:   arg1: x tile coordinate with door to open
                   arg2: y tile coordinate
     description:  opens closed door or portcullis
     return value: unknown
     -------------------------------------------------------------------------

     id=0026 name="set_race_attitude" ret_type=void
     parameters:   unknown
     description:  sets attitude for a whole race (?)
     -------------------------------------------------------------------------

     id=0027 name="place_object" ret_type=void
     parameters:   arg1: x tile pos
                   arg2: y tile pos
                   arg3: item pointer (from do_inv_create)
     description:  places a generated object in underworld (?)
     -------------------------------------------------------------------------

     id=0028 name="take_from_npc_inv" ret_type=void
     parameters:   unknown
     description:  unknown
     -------------------------------------------------------------------------

     id=0029 name="add_to_npc_inv" ret_type=void
     parameters:   unknown
     description:  (not used in uw1)
     -------------------------------------------------------------------------

     id=002a name="remove_talker" ret_type=void
     parameters:   none
     description:  removes npc the player is talking to (?)
     -------------------------------------------------------------------------

     id=002b name="set_attitude" ret_type=void
     parameters:   unknown
     description:  unknown
     -------------------------------------------------------------------------

     id=002c name="x_skills" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=002d name="x_traps" ret_type=int
     parameters:   unknown
     description:  unknown
     return value: unknown
     -------------------------------------------------------------------------

     id=002e name="x_obj_pos" ret_type=void
     parameters:   unknown
     description:  (not used in uw1)
     -------------------------------------------------------------------------

     id=002f name="x_obj_stuff" ret_type=void
     parameters:   unknown
     description:  unknown
     -------------------------------------------------------------------------

     id=0030 name="find_inv" ret_type=int
     parameters:   arg1: unknown
                   arg2: item id
     description:  searches item in npc inventory
     return value: position in master object list
     -------------------------------------------------------------------------

     id=0031 name="find_barter" ret_type=int
     parameters:   arg1: item id to find
     description:  searches for item in barter area
     return value: returns pos in master object list of item, or 0 if none
                   found
     -------------------------------------------------------------------------

     id=0032 name="find_barter_total" ret_type=int
     parameters:   s[0]: ???
                   s[1]: pointer to number of found items
                   s[2]: pointer to
                   s[3]: pointer to
                   s[4]: pointer to item ID to find
     description:  searches for item in barter area
     return value: 1 when found (?)
     -------------------------------------------------------------------------

   * Conversation imported variable

     All imported variables have type int (except for "npc_name" and
     "play_name", which are strings). Here's a list of all imported game
     variables:

       variable name       description

        play_hunger
        play_health
        play_arms
        play_power
        play_hp
        play_mana
        play_level
        new_player_exp     (not used in uw1)
        play_name          player name
        play_poison        (not used in uw1)
        play_drawn         is 1 when player has drawn his weapon (?)
        play_sex           (not used in uw1)
        npc_xhome          x coord of home tile
        npc_yhome          y coord of home tile
        npc_whoami         npc conversation slot number
        npc_hunger
        npc_health
        npc_hp
        npc_arms           (not used in uw1)
        npc_power
        npc_goal
        npc_attitude
        npc_gtarg
        npc_talkedto       is 1 when player already talked to npc
        npc_level
        npc_name           (not used in uw1)
        dungeon_level      (not used in uw1)
        riddlecounter      (not used in uw1)
        game_time
        game_days
        game_mins

   * Quest flags

     There are quest flags that are kept during gameplay to implement
     interaction between NPC's. flags can be get/set using get_quest() and
     set_quest() or during gameplay, triggered by actions. Here's a list of
     flags and their meanings (when no values for the flag are specified, 1
     means yes or true, and 0 means no or false):

       flag   description

         0    Dr. Owl's assistant Murgo freed
         1    talked to Hagbard
         2    met Dr. Owl?
         3    permission to speak to king Ketchaval
         4    Goldthirst's quest to kill the gazer (1: gazer killed)
         5    Garamon, magic source
         6    friend of Lizardman folk
         7    ?? (conv #24, Murgo)
         8    book from Bronus for Morlock
         9    "find Gurstang" quest?
        10    where to find Zak, for Delanrey
        11    Rodrick killed

        32    status of "Knight of the Crux" quest
               0: no knight
               1: seek out Dorna Ironfist
               2: started quest to search the "writ of Lorne"
               3: found writ
               4: door to armoury opened


6.0 Savegame format

   Savegames are stored in folders called "SaveN", where N is the number
   of the save game. Ultima Underworld only allows 4 save game slots.

   The file "player.dat" contains the main character data. The first 220 bytes
   are encrypted with a rather simple algorithm. Byte 0 in the file is the
   starting xor value. Byte 1 is xor'ed with xorvalue + 3, and for each next
   byte, the xorvalue is incremented by 3. A simple implementation in C is here:

      // descramble data
      unsigned char xorvalue = data[0];
      unsigned char incrnum = 3;

      for(int i=1; i<=220; i++)
      {
         if (i==81) incrnum = 3;
         data[i] ^= (xorvalue+incrnum);
         incrnum += 3;
      }

   After decryption, the file contains the following:

   0000   Int8    unused (was starting xor value)
   0001   14*char character name
   ...
   001F   Int8    Strength
   0020   Int8    Dexterity
   0021   Int8    Intelligence
   0022   Int8    Attack
   0023   Int8    Defense
   0024   Int8    Unarmed
   0025   Int8    Sword
   0026   Int8    Axe
   0027   Int8    Mace
   0028   Int8    Missile
   0029   Int8    Mana
   002A   Int8    Lore
   002B   Int8    Casting
   002C   Int8    Traps
   002D   Int8    Search
   002E   Int8    Track
   002F   Int8    Sneak
   0030   Int8    Repair
   0031   Int8    Charm
   0032   Int8    Picklock
   0033   Int8    Acrobat
   0034   Int8    Appraise
   0035   Int8    Swimming
   ...
   0037   Int8    max. vitality
   0038   Int8    current mana
   0039   Int8    max. mana
   ...
   003E   Int8    character level
   ...
   0045   3*8bits rune flags (*)
   ...
   004D   Int16   weight in 0.1 stones
   004F   Int32   experience in 0.1 points
   ...
   0055   Int16   x-position in level
   0057   Int16   y-position
   0057   Int16   z-position
   005B   Int16   heading
   005D   Int16   dungeon level
   ...
   00DD   Int8    current vitality

   (*) The rune field is a bitfield, where an 1 indicates an available
       rune. Bits are seen from most to least significant. The 'A' rune is
       stored in bit 7 of the first field.

   todo: how items are stored


7.0 3D object models

   These are stored within the executable (bad! bad!). From Doug Church, on
   the 3d models:

     We'd take a 3ds model, convert it to an internal ASCII format, and then
     run a "model builder" which would generate an inlined BSP tree for it.
     This would be expressed in a byte code, or, really, as a set of simple
     ASM like codes.  Things like "Vtx 56.7, 435, 35.3" or "Color 153" or
     "Norm 0.6, 0.8, 0.0, front04" or whatever.  Then, we used the Macro
     Assembler (well, Optasm, really) to generate a bunch of "db" statements
     out of all this, and give it a label, and put it in the data segment. 3D
     models were then drawn by calling a little "model interpreter" in the
     game, which was given the address of this data block, which it then
     interpreted. i.e. when it got to the byte for "Norm", it would fetch the
     normal, dot it verse the eye vector, and jump or not based on the sign.

   There is a table of 2-byte model offsets, with room for 64 models.
   Positions of the table differ, as there are several builds of the uw.exe,
   ultimau1.exe or uw2.exe.

     game  table start   first bytes   table base offset
      uw1  0x0004e910    b6 4a 06 40   0x0004e99e
      uw1  0x0004ccd0    b6 4a 06 40   0x0004cd5e  same models, different place
      uw1  0x0004e370    b6 4a 06 40   0x0004e3fe  ditto (reported Gerd Bitzer)

      uw2  0x00054cf0    d4 64 aa 59   0x00054d8a
      uw2  0x000550e0    d4 64 aa 59   0x0005517a  another UW2 build

   Models are:

      00   -
      01   door frame
      02   bridge
      03   bench
      04   Lotus Turbo Esprit (no, really!)
      05   small boulder
      06   medium boulder
      07   large boulder
      08   arrow
      09   beam
      0A   pillar
      0B   shrine
      0D   painting
      10   texture map
      11   texture map
      12   texture map
      13   gravestone
      14   texture map
      15   -
      16   ?texture map
      17   
      18   table
      19   chest
      1A   nightstand
      1B   barrel
      1C   chair
      1D   bed (UWII)
      1E   blackrock gem (UWII)
      1F   shelf (UWII)

   Node list
   ---------
   Actual model data is stored as a list with various "nodes" that do
   different things. There also is a vertex array that is filled at start of
   the model, and then faces are defined, using points from the vertex list.
   The list is parsed every frame and tests are done if some faces have to be
   rendered or not (depending if the player faces the polygon or not).

   There are some data types that are used in the model node data. These are:

     Int16   a simple 16 bit unsigned integer
     Fixed   fixed point number with 12 bits before the fraction point (12.4)
     VertNo  vertex number; lowest 3 bits are ignored

   Every model has a header that looks like this:

     0000   Int32   unknown
     0004   Fixed   extents X value
     0006   Fixed   extents Y value
     0008   Fixed   extents Z value
     000a           node entries follow

   In general, node entries look as following:

     0000   Int16   node id
     0002           custom node data (may be omitted)

   Here's an overview of all node types used:

     node id  description
     0000     end node
     0006     define sort node, arbitrary heading
     000C     define sort node, ZY plane
     000E     define sort node, XY plane
     0010     define sort node, XZ plane
     0014     ??? colour definition
     002E     ???
     0040     ??? seems to do nothing but introduce a face definition
     0044     ??? this one too
     0058     define face plane, arbitrary heading
     005E     define face plane Z/Y
     0060     define face plane X/Y
     0062     define face plane X/Z
     0064     define face plane X
     0066     define face plane Z
     0068     define face plane Y
     0078     define model center
     007A     define initial vertex
     007E     define face vertices
     0082     define initial vertices
     0086     define vertex offset X
     0088     define vertex offset Z
     008A     define vertex offset Y
     008C     define vertex variable height
     0090     define vertex offset X,Z
     0092     define vertex offset X,Y
     0094     define vertex offset Y,Z
     00A0     ??? shorthand face definition
     00A8     define texture-mapped face
     00B4     define face vertices with u,v information
     00BC     define face shade (6 bytes)
     00BE     ??? seems to define 2 shades
     00CE     ??? yet another texture-mapped face
     00D2     ??? shorthand face definition
     00D4     define dark vertex face (?)
     00D6     define gouraud shading

   Here's a detailed description of all nodes, sorted after functionality:

   Misc. nodes
   -----------
     0000   end node
            just ends current list; also ends sort node sublists

     0078   define model center
              0000   Int16     node id
              0002   VertNo    vertex list index to use as origin (?)
              0004   Fixed     origin X coordinate
              0006   Fixed     origin Y coordinate
              0008   Fixed     origin Z coordinate
              000a   Int16     ???

            because of the limited resolution available for specifying object
            positions, the origin for model coordinates will typically need to
            be offset from the center of the collision volume. This parameter
            gives that center, in model coords.

   Vertex nodes
   ------------
   Vertex node entries just set up the vertex list that is later used to take
   points and draw faces (such as triangles, polygons, etc.)

     007A   define initial vertex
              0002   Fixed     vertex X coordinate
              0004   Fixed     vertex Y coordinate
              0006   Fixed     vertex Z coordinate
              0008   VertNo    vertex list index to store new vertex

     0082   define initial vertices
              0002   Int16     number of vertices (=nvert)
              0004   Int16     ???
              0006   Fixed     vertex X coordinate for first vertex
              0008   Fixed     vertex Y coordinate
              000a   Fixed     vertex Z coordinate
              000c   Fixed     vertex X coordinate for second vertex
              000e             and so on, for nvert vertices

     0086   define vertex offset X
              0002   VertNo    reference vertex to modify
              0004   Fixed     offset to add to X coordinate
              0006   VertNo    new list index to store vertex

     0088   define vertex offset Z
            same as 0086, but for the Z coordinate

     008A   define vertex offset Y
            same as 0086, but for the Y coordinate

     0090   define vertex offset X,Z
              0002   Fixed     offset to add to X coordinate
              0004   Fixed     offset to add to X coordinate
              0006   VertNo    reference vertex to modify
              0008   VertNo    new list index to store vertex

     0092   define vertex offset X,Y
            same as 0090, but for the X and Y coordinate

     0094   define vertex offset Y,Z
            same as 0090, but for the X and Y coordinate

     008C   define vertex variable height
            this is used for pillars and doorframes where the model must reach
            up to the ceiling, wherever it be.
              0002   VertNo    reference vertex to modify
              0004   Int16     ???
              0006   VertNo    new list index to store vertex

   Face plane checks
   -----------------
   Face plane checks exist to check if a following face has to be drawn or
   not. Usually a face normal vector is defined to verify. A length value
   is given to know how many bytes to omit in the node list.

     0058   define face plane, arbitrary heading
              0002   Int16     number of bytes to skip when not visible
              0004   Fixed     normal vector X coordinate
              0006   Fixed     distance "model origin -> face" X value
              0008   Fixed     normal vector Y coordinate
              000a   Fixed     distance "model origin -> face" Y value
              000c   Fixed     normal vector Z coordinate
              000e   Fixed     distance "model origin -> face" Z value
            after this node usually face info nodes follow

     0064   define face plane X
            Y and Z coordinates of normal vector is 0 (YZ plane normal)
              0002   Int16     number of bytes to skip when not visible
              0004   Fixed     normal vector X coordinate
              0006   Fixed     distance "model origin -> face" X value
            after this node usually face info nodes follow

     0066   define face plane Z
            same as 0064, but with Z coordinate (XY plane normal)

     0068   define face plane Y
            same as 0064, but with Y coordinate (XZ plane normal)

     005E   define face plane Z/Y
            X coordinate of normal vector is 0
              0002   Int16     number of bytes to skip
              0004   Fixed     normal vector Z coordinate
              0006   Fixed     distance Z value
              0008   Fixed     normal vector Y coordinate
              000a   Fixed     distance Y value

     0060   define face plane X/Y
            same as 005E, but with X and Y coordinates/values (in this order)

     0062   define face plane X/Z
            same as 005E, but with X and Z coordinates/values

   Face info nodes
   ---------------
   They just define a face (polygon) from some points of the vertex list.

     007E   define face vertices
              0002   Int16     number of vertices (=nvert)
              0004   VertNo    vertex list index for first point
              0006   VertNo    vertex list index for second point
              0008             and so on

     00A8   define texture-mapped face
            vertex u and v coordinates are stored as 0.16 fractional value.
            just divide by 65535.0 to get coordinates in the range [0; 1]
              0002   Int16     texture number (?)
              0004   Int16     number of vertices (=nvert)
              0006   VertNo    vertex list index for first point
              0008   Fixed      first vertex u coordinate
              000a   Fixed      first vertex v coordinate
              000c   VertNo    vertex list index for second point
              000e             and so on

     00B4   define face vertices with u,v information
            same structure as 00A8, but without the "texture number" field.

   Sort nodes
   ----------
   Sort nodes are there to sort faces of a whole node list and the renderer
   can determine if the list has to be rendered at all.

     0006   define sort node, arbitrary heading
              0002   Fixed     normal vector X coordinate
              0004   Fixed     distance      X coordinate
              0006   Fixed     normal vector Y coordinate
              0008   Fixed     distance      Y coordinate
              000a   Fixed     normal vector Z coordinate
              000c   Fixed     distance      Z coordinate
              000e   Int16     left node offset (starting at 0010)
              0010   Int16     right node offset (starting at 0012)

     000C   define sort node, ZY plane
            the X coordinate values are assumed to be 0
              0002   Fixed     normal vector Z coordinate
              0004   Fixed     distance      Z coordinate
              0006   Fixed     normal vector Y coordinate
              0008   Fixed     distance      Y coordinate
              000a   Int16     left node offset (starting at 000c)
              000c   Int16     right node offset (starting at 000e)

     000E   define sort node, XY plane
            same as 000C, but with X and Y coordinates (in this order)

     0010   define sort node, XZ plane
            same as 000C, but with X and Z coordinates (in this order)

   Unknown nodes
   -------------
     0014   ??? colour definition
              0002   VertNo    vertex number
              0004   Int8      c1 ???
              0005   Int8      c2 ???
              0006   VertNo    vertex number

     002E   ???
              0002   Int16     ???

     0040   ??? seems to do nothing but introduce a face definition
     0044   ??? this one too
            no further node data

     00BC   define face shade
              0002   Int8      c1 ???
              0003   Int8      c2 ???
              0004   Int8      c3 ???
              0005   Int8      ???

     00BE   ??? seems to define 2 shades
              0002   Int8      c1 ???
              0003   Int8      ???
              0004   Int8      ???
              0005   Int8      ???

     00CE   ??? yet another texture-mapped face
            same data as 00B4

     00A0   ??? shorthand face definition
            seems to be a quick way to define a face with 4 vertices and
            automatic texture coordinates; vertex list indices
              0002   VertNo    ???
              0004   Int8      vertex list index 0
              0005   Int8      vertex list index 1
              0006   Int8      vertex list index 2
              0007   Int8      vertex list index 3

     00D2   ??? shorthand face definition
            same as 00A0

     00D4   define dark vertex face (?)
              0002   Int16     number of vertices (=nvert)
              0004   Int8      c1 ???
              0005   Int8      c2 ???
              0006   VertNo    vertex list index for first point
              0008   Int8      dark value for first point ???
              0009   VertNo    vertex list index for second point
              000b   Int8      dark value for second point ???
                               and so on; if nvert is odd, read another empty
                               byte to have 16 bit word align

     00D6   define gouraud shading
            no other info; may switch on gouraud shading

   Ultima Underworld 2 models
   --------------------------

   Notes from Fabian Pache (http://uw2rev.sourceforge.net) for UW2 models:

   I am not concerned with recreating the original 3D models because 
   (1) they are stored within the executable (thanks Ulf Wohlers)
   (2) they are rather poor
   Therefore I replace the old objects with new ones.

   There are two types of 3D objects: Dynamic and Static objects
   The following information has not been obtained by debugging, disassembling
   or any other kind of dark magic, but rather by observing and 
   crossreferencing various files. It may not be the way UW" really does things,
   but it's the way things look. 
   I'll refer to unknown as variable1 and to link2 as
   variable2 as their usage is... well, variable.

7.1 Dynamic objects

   Dynamic objects either have a context sensitve geometry, like pillars or
   they have context sensitive textures (tmap, bridge...). I'll be talking
   about a cube size a lot - what I mean is the size of a tile

7.1.1 Pillars
   The position given by the item is the southwest corner of the pillar,
   It obviously spans from floor to ceiling. Texture is stored in tmobj.gr
   Texture index are the 2 least significant bits of the flags
   
7.1.2 Bridges

   Bridges are used for two things: Bridging gaps and altering or lowering the ceiling
   If bit 2 and 3 of the flags are set it's a ceiling, otherwise it's a bridge.

7.1.2.1 Real bridges

   Bridges are textured by tmobj.gr textures. Use index 30 + bits 0 and 1 of the flags.
   Description is "Bridge".

7.1.2.2 ceilings

   Texture is still unknown. Suspect some offset + bit 0 and 1 of the flags into
   the texture mapping of the level. Description is texture dependant

7.1.3 Tmap

   There are two tmap objects for uw2. objects.gr names one as tmap_c and the other as
   tmap_s. Looking into the difference. 
   [ tmap_c is usually used as wall decal -> no collision detection
   [ tmap_s is usually used to insert new (thin) walls -> collision detection
   [ not too sure about this ]
   tmap_c (index 366) and tmap_s (index 367) use a texture from t64.tr.
   Index is variable1 resolved with the level's texturemapping. Description is
   the texture's description
   Any tmap is a square object of tile size, whose lower center is given by the items
   coordinates. [Figure out the exact offsets]

7.2 Static objects

   Though formerly defined in code these objects always look the same. Only 
   interesting point remaining is the base of the coordinate system


8.0 Misc. stuff


8.2 Graves

   Graves. (Dig those graves!) There are 2 bitmaps available for graves: 28
   and 29 in tmobj.gr. Which one is drawn in the model depends on the low bits
   of the "state" field, as usual. Headstone text is determined by the "link"
   field: the high (512) bit seems always to be set, the rest is the string
   index in the object message block 0008. This also serves as an index into
   grave.dat which in turn gives a unique grave ID.

   Large headstone images live in the cutscene file cuts/cs401.n01, one frame
   each, indexed by grave ID.

8.3 Terrain texture properties

   The file terrain.dat in the data directory contains information on the
   terrain types represented by the various wall and floor textures. There is
   a 16-bit word per texture, up to a maximum of 256 walls and 256 floors.
   Floor data therefore starts at file offset 0x200. Terrain types are:

    0000    Normal (solid) wall or floor
    0002    Ankh mural (shrines)
    0003    Stairs up
    0004    Stairs down
    0005    Pipe
    0006    Grating
    0007    Drain
    0008    Chained-up princess
    0009    Window
    000a    Tapestry
    000b    Textured door (used for the lock to the Key of Infinity)
    0010    Water (not waterfall)
    0020    Lava (not lavafall)
    0040    Waterfall      - UW2
    00C0    Ice wall       - UW2
    00D8
    00E8    Ice walls (crumbling?)
    0080    Lavafall       - UW2
    00F8    Ice            - UW2

8.4 Sound effects

   The file "sounds.dat" in the "sound" folder contains sound effect data.
   The file starts with an Int8 value that is the number of data entries in
   the file. Then 5 Int8 bytes for each entry in the file follow.
   It is supposed that the data may be midi commands to play back the sfx.

eof
