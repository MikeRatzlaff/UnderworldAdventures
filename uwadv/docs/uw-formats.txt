Ultima Underworld Formats Specification
---------------------------------------


Table of Contents

1.0   General stuff
1.1   Summary of data files

2.0   Level Map File
2.1   Palettes
2.2   Textures
2.3   Graphics
2.4   Fonts
2.5   Bitmaps
2.6   Palette mappings

3.0   Object IDs
3.1   Common object properties
3.2   Object class properties
3.3   Traps

4.0   Game strings
4.1   Conversations

5.0   Critter Animation
5.1   Cutscene Animations

6.0   Savegame format

7.0   3D objects

8.0   Misc. stuff
8.1   Combining objects
8.2   Graves
8.3   Terrain texture properties


1.0 General stuff

   In this document, all integers are refered as Int8, Int16 or Int32,
   depending on their number of bits.

   All files from Ultima Underworld are in little endian format, that means
   that the low-byte of an Int16 intever comes first in the file, and is
   followed by the high-byte.

   Most of the stuff in this file is from the original "uw-specs.txt" found
   in "The System Shock Hack Project". System Shock uses almost the same
   data structures for the game. Many thanks to Jim Cameron!

   Copyright (c) 2000,2001,2002 Jim Cameron
   Copyright (c) 2002 Michael Fink

   Additional information from:

   Alistair Brown (basic object format, via the Underworld II editor
      <http://bearcity.pwp.blueyonder.co.uk/>)

   Ulf Wohlers (Objects and 3D models)


1.1 Summary of data files

   Here are all files found in the "data" folder:

   3dwin.gr       3d window graphics
   allpals.dat    auxilliary 4-bit palette indices
   animo.gr       small animations
   armor_f.gr     female paperdoll armor graphics
   armor_m.gr     male paperdoll armor graphics
   babglobs.dat   initial conversation globals
   blnkmap.byt    blank map bitmap, palette #1
   bodies.gr      paperdoll bodies
   buttons.gr     buttons, seems to be from some map editor
   chains.gr      rotating chains for the stats window
   chargen.byt    character generation bitmap, palette #3
   charhead.gr    character images, for conversations
   chrbtns.gr     character generation graphics, palette #3
   chrgen.dat
   cmb.dat        combining rules (see 8.1)
   cnv.ark        conversation scripts
   comobj.dat     common object properties
   compass.gr     compass graphics
   conv.byt       seems to be a conversation screenshot, palette #0
   converse.gr    conversation screen bitmaps
   cursors.gr     mouse cursor images
   doors.gr       doors textures (may be decals)
   dragons.gr     scroll dragons animations
   eyes.gr        eyes from top screen
   f16.tr         floor/ceiling textures, size 16x16
   f32.tr         floor/ceiling textures, size 32x32
   flasks.gr      health and mana flask graphics
   font4x5p.sys   small font
   font5x6i.sys   italic font, used in character stats screen
   font5x6p.sys   normal font, used for scroll messages
   fontbig.sys    big font, for cutscenes
   fontbutn.sys   font for buttons (?)
   fontchar.sys   character generation font (?)
   genhead.gr     heads images
   grave.dat      grave IDs
   heads.gr       avatar character generation heads
   inv.gr         inventory graphics, scroll backgrounds (?)
   lev.ark        level maps, texture indices and object list
   lfti.gr        left menu buttons
   light.dat      palette mappings for 16 different light levels
   lights.dat
   main.byt       main game screen bitmap, palette #0
   mono.dat       palette mapping for grayscale colors
   objects.dat    object data specific to an object class
   objects.gr     object graphics, some never seen in inventory (460 objects!)
   opbtn.gr       opening screen buttons, create new game, etc.; other palette
   opscr.byt      opening screen, palette #2
   optb.gr        some options buttons
   optbtns.gr     all options buttons from the left menu
   pals.dat       eight palettes (#0 to #7, #5 and #6 are the same)
   panels.gr      some invalid type, 0x0 and 1x1 resolution images
   player.dat     initial player character called "gronkey"
   power.gr       hit power indicator graphics
   pres1.byt      "origin presents" screen, palette #5
   pres2.byt      "a blue sky prod. game" screen, palette #5
   question.gr    a single question mark
   scrledge.gr    scroll paper edges
   shades.dat
   skills.dat
   spells.gr      spells graphics
   strings.pak    all the game strings
   terrain.dat    terrain texture properties (see 8.3)
   tmflat.gr      wall switches and other decals
   tmobj.gr       more wall decals
   uw.cfg         underworld configuration (audio, cut scenes)
   views.gr       the letters "mv", probably not used
   w16.tr         wall textures, size 16x16
   w64.tr         wall textures, size 64x64
   weapons.cm
   weapons.dat
   weapons.gr     weapon hit animations, for left and right handedness
   win1.byt       winning screen with text, palette #7
   win2.byt       blank winning screen for character info, palette #7
   xfer.dat

   Here are all files found in the "sound" folder:

   XX.voc         all cutscene audio files
   uwXX.xmi       underworld extended midi music
   awXX.xmi       the same, for adlib music (?)
   sounds.dat
   uw.mt          MT32 sysex data
   uw.ad          adlib stuff
   *.adv          device driver for midi/wave output

   Here are all files found in a save game (e.g. "Save1") folder:

   lev.ark        modified level map
   bglobals.dat   conversation globals (initialized)
   desc           savegame name
   player.dat     character info


2.0 Level Map File

   Level maps are stored in file "lev.ark". The header of the file contains
   the offsets to all the chunks in the level archive. First there is a Int16
   value giving the number of chunk directory entries (0x0087 = 135 for 9x15
   possible chunks) followed by Int32 offset for each chunk (measured from the
   start of the file).

   Chunks are arranged in blocks of 9 (Ultima Underworld 1 has 9 levels, Abyss
   levels 1 - 8 and the Ethereal Void). There is space in the header for 15
   such blocks, though only 5 are actually used.

   When the offset is a value of 0, the chunk or block is not available and
   contains no data. There are 45 offsets which point to different data:

   <9 blocks level map/object info>
   <9 blocks object animation overlay info>
   <9 blocks level texture usage>
   <9 blocks level automap flags>
   <9 blocks level comment entries>

   * Level map info

     The level map chunk for each level contains information about the level
     architecture (tile map) and the objects which live in it:

      Offset  Size   Description
      0000    4000   Tile map (64 x 64 x 4 bytes)
      4000    1b00   Mobile object information (objects 000-0ff, 256 x 27bytes)
      5b00    1800   Static object information (objects 100-3ff, 768 x 8bytes)
      7300    01fc   Free list for mobile objects (objects 002-0ff, 254 x 2bytes)
      74fc    0600   Free list for static objects (objects 100-3ff, 768 x 2bytes)
      7afc    0104   Unknown (260 bytes)
      7c00    0002
      7c02    0002   No. entries in mobile free list minus 1
      7c04    0002   No. entries in static free list minus 1
      7c06    0002   0x7775 ('uw')

     Tile map
     --------
     Levels are always 64 x 64 tiles. Map origin is at the lower left tile,
     going to the right, each line in turn. For each tile there are two Int16
     values stored. The two values can be split into bits:

     00 tile properties / flags:

        bits      len  description
         0 -  3    4   tile type (0-9, see below)
         4 -  7    4   floor height
         8 -  9    2   unknown, always 0
        10 - 13    4   floor texture index (from level texture usage block)
        14         1   unknown (only used on level 6, near the shrine)
        15         1   door bit (when 1, a door is present)

     02 tile properties 2 / object list link

        bits      len  description
         0 -  5    6   wall texture index (from level texture usage)
         6 - 15   10   first object in tile (index into master object list)

     Underworld tile types are:
      00      Solid (wall tile)
      01      Open (square tile of empty space)
      02      Diagonal, open SE
      03      Diagonal, open SW
      04      Diagonal, open NE
      05      Diagonal, open NW
      06      Sloping up to the north
      07      Sloping up to the south
      08      Sloping up to the east
      09      Sloping up to the west

     Mobile / Static object info
     ---------------------------
     The master object list is stored after the map data. There are 1024
     entries (0x400) in the table. The first 256 entries contain infos about
     mobile objects (NPCs, critters) and have 8 + 19 bytes each.

     0000   Int16*4   general object infos
     0008   19        mobile object infos (see below)

     The reamaining 768 object entries starting at 0x100 only have general
     object infos and are 8 bytes long each.

     General object infos
     --------------------
     They contain 4 Int16 words which can be split into bits:

     00 objid / flags:      0- 8   Object ID (see below)
                              12   Enchantment flag (enchantable objects only)
                              15   Link flag (link field is quantity/special)

     02 position:           0- 6   Object Z position (0-127)
                            7- 9   Heading (*45 deg)
                            10-12  Object Y position (0-7)
                            13-15  Object X position (0-7)

     04 quality / chain:    0- 5   Quality
                            6-15   Index of next object in chain

     06 link / special:     0- 5   Owner / special
                            6-15   Quantity / link / special property

     Object chaining
     ---------------
     Objects in a tile are stored as a linked list, where the "Index of next
     object in chain" points to the next object in list, or contains 0 for the
     end of the linked list. The first object in the list is determined by the
     tile's object index value (see above, at "Tile map").

     For normal objects, the "Owner" field describes the NPC type the object
     belongs to. NPC object ID = Owner - 1 + 0x0040. When the field is 0, the
     object doesn't belong to anyone.

     Link Field
     -----------
     The link field can be used for various things. If the link flag is unset,
     it contains the index of an associated object. The exact meaning varies,
     but is generally a "has-a" type relationship (contents, trap to set off,
     spell).

     If the link flag is set, this field is a quantity or special property.
     Quantity is straightforward; if the value is less than 512 it gives the
     number of a stackable item that are present in the stack, so identical
     items may be combined into one object definition.

     Quantities >= 512 are special properties. The value is the link field
     minus 512 (unsurprisingly), the meaning depends on object type and flags.

     Enchantments
     ------------
     If the enchantment flag is set and the object is enchantable, then the
     link field (less 512) determines the enchantment. Enchantment names are
     stored in strings chunk 5. The way in which the link value maps onto
     spells in this chunk depends on the object type.

     Most objects seem to use spells 256-320 (add 256) if the enchantment
     number is in the range 0-63, otherwise they add 144 to use spells 208 and
     up. Healing fountains, however, don't use a correction at all.

     Weapons and armour have a more complex mapping. Most enchanted weapons and
     pieces of armour have an enhancement for Accuracy, Damage, Protection or
     Toughness, which are spells 448-479 in the main spell list. These map to
     special property values 192-207. Yes, there are only 16 values for 32
     spells; enchanted armour adds another 16 to the spell index to bring it
     into the armour enchantment range. However, these items may also carry
     generic enchantments, in which case the special properties map to spells
     0-255 (and armour doesn't apply a special correction).

     Wands don't hold their enchantments directly in the quantity field, since
     they also need to store the number of charges remaining. Instead, they
     link to a spell object which holds the enchantment; it seems here that
     the "quality" field of the spell object determines the number of charges.
     Other objects may also carry spells in this way.

     Links
     -----
     When the link field is a link (link flag NOT set), it links to another
     object(s). Here's a list of IDs and the lin meanings:

      0040 - 007f: all sorts of NPCs (link point to inventory start)
      0080 - 008e: all sorts of container (points to content)
      008f: a_rune bag (specially treated)
      0098 - 009f,00aa: all sorts of wands (points to a "a_spell" object)
      0140 - 014f: doors (points to a "a_lock" object, when locked)
      015b, 015e: a_chest, a_barrel (3d objects)
      0161: a_lever (mostly points to "a_use trigger" object)
      016e: special tmap obj (?)
      0170 - 017f: button, switches etc. (points to "a_use trigger" object)
      0187: a_create object trap (points at object to create)
      0188: a_door trap (usually points to "a_lock" object)
      01a0: a_move trigger
      01a2: a_use trigger
      01a3: a_look trigger
      01a5: an_open trigger
      01a6: an_unlock trigger

   * Object animation overlay info

     The 9 blocks contain entries with length of 6 bytes with infos about
     objects with animation overlay images from "animo.gr".
     It always is 0x0180 bytes long which leads to 64 entries.

     0000   Int16   link1
     0002   Int16   unk2
     0004   Int8    tile x coordinate
     0005   Int8    tile y coordinate

     link1's most significant 10 bits contain a link into the object table,
     to the object that should get an animation overlay.

   * Level texture usage

     0000  48 x Int16   wall texture number (from w64.tr)
     0060  10 x Int16   floor texture number (from f32.tr)
     0074   6 x Int16   door decal number (from doors.gr (?))

   * Level automap flags

     each block contains the "visited" bytes for each level. Each byte
     describes a tile on the main map. The block size always is 0x1000.

   * Level comment entries

     not decoded yet


2.1 Palettes

   * 256 color palettes

     In "palette.dat" there are stored 8 different palettes. One palette has the
     following layout:

     0000  Int8  blue  intensity, index 0, range [0..63]
     0001  Int8  green intensity, index 0, range [0..63]
     0002  Int8  red   intensity, index 0, range [0..63]

     0003  Int8  blue  intensity, index 0, range [0..63]
     ...

     In each palette there are stored color intensities for 256 colors. All 8
     palettes are stored sequentially in the file.

     Palette index 0 always is a transparent pixel.

   * 16 color auxiliary palettes

     In "allpals.dat" there are several auxiliary palettes, used for 4-bit
     graphics. All indices use palette #0.

     0000  Int8  index to first color
     0001  Int8  index to second color
     ...

     There are 16 values that are indices for palette #0. They build a 16 color
     palette from selected colors of the palette #0.

     In the file "allpals.dat" there are stored 0x1f (=31) such palettes.

   * palette rotation animations

     In the game, in several places the palette is used to create animated
     effects, such as the lava and water textures. Here are described the
     palette indices that have to be rotated to produce the animations:

     - Palette #0: in game graphics

       indices 16 through 23: lava fire effect
       indices 48 through 51: water effect

     - Palette #2: game start screen

       indices 64 through 127: "Ultima Underworld" logo warping effect


2.2 Textures

   Textures are stored in "*.tr" files, where "fXX.tr" files are floor
   textures, and "wXX.tr" are wall textures. XX describes the width and height
   resolution of the texture.

   0000  Int8   unknown, always seems to be 2
   0001  Int8   x and y resolution (textures always square)
   0002  Int16  number of textures
   0004  Int32  offset to texture #0
   0008  Int32  offset to texture #1
   ...

   The offset of each texture points to the actual texture palette indices,
   which are xyres^2 bytes long. Textures always use palette #0.


2.3 Graphics

   Graphics are stored in "*.gr" files and can be 8-bit or 4-bit.

   0000  Int8   unknown, always seems to be 1
   0001  Int16  number of bitmaps
   0003  Int32  offset to bitmap #0
   0007  Int32  offset to bitmap #1
   ...

   Each bitmap has its own header:

   0000  Int8   bitmap type:
                04: 8-bit uncompressed
                08: 4-bit run-length
                0A: 4-bit uncompressed
   0001  Int8   width
   0002  Int8   height

   For the 4-bit formats, there follows another Int8 that selects the
   auxiliary palette to use (see 2.1).

   000n  Int16  size of data for the bitmap.
                in 4-bit formats, this is the number of 4-bit nibbles, not
                bytes.

   The file "panels.gr" contains bitmaps that don't have a bitmap header, but
   immediately starts with image data. The bitmaps are of type 04 and have
   width of 83 and height of 114.

   * uncompressed bitmaps (04: 8-bit, 0A: 4-bit)

     all palette indices are stored sequentially, first one line, then the
     next, and so on. For the 4-bit format, first take the upper nibble, then
     the lower nibble.

   * compressed bitmaps (type 08)

     All pixels are run-length encoded. when a new byte has to be retrieved,
     first take the high nibble, then the low nibble of that byte.

     Data consists of repeat and run records. Repeat records let the decoder
     repeat a single nibble a certain number of times. The run record takes
     a certain number of next nibbles to be as uncompressed. The two records
     alternate in the bitmap, starting with a repeat record.

     For every record, first there is a count to retrieve. Get a nibble; if
     it is not 0, it is a count. Otherwise, get two more nibbles, n1 and n2.
     The count is  c = (n1 << nibblesize) | n2. If the count is still zero,
     take another three nibbles, and calculate the count:
       c = (((n1 << nibblesize) | n2) << nibblesize) | n3;
     A count is at most 6 nibbles long.

     A run record consists of a count and then follows 'count' nibbles,
     that are the raw pixel data. A repeat record consists of a count and
     a single nibble, the nibble is then repeated 'count' times.

     As there is no point in repeating a nibble <3 times, there are some
     special meanings for count:
     1: skip this record, the next one is a run record again. may be used at
        the beginning of a file, when it should start with a run rather than
        a repeat.
     2: multiple repeats. get another count, and process 'count' times a
        repeat record.

     NOTE that there also exists a 5-bit compressed format which is exactly
     the same as the above except that the word length is 5 bits instead of 4.
     This is used for critter animation frames in the crit/ folder. The
     auxiliary palette contains 32 entries and is stored with the animation.


2.4 Fonts

   Fonts are stored in "font*.sys" files, and can be non-proportional (chars
   can have different lengths). The header looks as this:

   0000  Int16   unknown, always 1 (might be size of character width field)
   0002  Int16   size of single character, in bytes (=charsize)
   0004  Int16   width of the blank (space) character, in pixels
   0006  Int16   font height in pixels
   0008  Int16   width of a character row in bytes
   000A  Int16   maximum width of a character in pixels (=maxwidth)

   Then follow all bitmaps for each character. The number of chars can be
   determined by (filelen-12) / (charsize+1). Bitmaps are stored as 1-bit
   patterns, starting at the most significant bit in the current byte. When
   a new line in character bitmap begins, remaining bits are unused and a new
   byte in the file is taken.

   After 'charsize' number of bytes, there is another Int8 that says the width
   for the current character in pixels.

   Note: at least the fonts "fontbig.sys" and "font5x6p.sys" contain overly
   large characters, and for these the remaining bits at a line are used. The
   maxwidth field should be corrected for loading.


2.5 Bitmaps

   "*.byt" files are just 320x200 bitmaps, using palette indices from
   different main palettes. Here's a list of all bitmap files:

    blnkmap.byt    blank map bitmap, palette #1
    chargen.byt    character generation bitmap, palette #3
    conv.byt       seems to be a conversation screenshot, palette #0
    main.byt       main game screen bitmap, palette #0
    opscr.byt      opening screen, palette #2
    pres1.byt      "origin presents" screen, palette #5
    pres2.byt      "a blue sky prod. game" screen, palette #5
    win1.byt       winning screen with text, palette #7
    win2.byt       blank winning screen for character info, palette #7


2.6 Palette mappings

   Palette mappings for different light/darkness levels are stored in the
   file "light.dat". The file consists of 16 blocks of palette mappings. Each
   block contains 256 Int8 values who map colors to their palette indices in
   the game palette. The first block is the mapping for original colors, and
   the last one is for "almost black".

   The file "mono.dat" contains palette mappings that maps colors to grayscale
   values. It has the same format as the "light.dat" file and can be
   interchanged to get a gray underworld look. It is used for the spell
   "invisibility".


3.0 Object IDs

   0000-001F  Weapons and missiles
   0020-003F  Armour and clothing
   0040-007F  Monsters
   0080-008F  Containers
   0090-0097  Light sources
   0098-009F  Wands
   00A0-00AF  Treasure
   00B0-00BF  Comestibles
   00C0-00DF  Scenery and junk
   00E0-00FF  Runes and bits of the Key of Infinity
   0100-010F  Keys, lockpick, lock
   0110-011F  Quest items
   0120-012F  Inventory items, misc stuff
   0130-013F  Books and scrolls
   0140-014F  Doors
   0150-015F  Furniture
   0160-016F  Pillar, some decals, force field, special tmap (?)
   0170-017F  Switches
   0180-019F  Traps
   01A0-01BF  Triggers
   01C0-01CF  Explosions/splats, fountain, silver tree, moving things

   Description for each object is stored in game strings, block 0004


3.1 Common object properties

   These are stored in the file "comobj.dat". The number of object properties
   is determined by (filelen-2) / 11  (each entry is 11 bytes long)

   The first two bytes contain unknown information. Each entry has the
   following format:

   0000  Int8    armour (ID?)
   0001  Int16   mass in 0.1 stones; (lower 4 bits are stuff2, ??)
   0003  Int8    flags (lower 4 bits only)
                 0/2: object in range [336, 368[ seem to be 3d objects
                 4:   decal object
   0004  Int16   value (?)
   0005  Int24   unknown1
   0008  Int8    scale value (?)
   0009  Int8    unknown2
   000A  Int8   lower 4 bits are quality type 0-f

   Each possible value of "quality type" maps onto a group of 6 strings in
   chunk 4 from lowest to highest quality. Items which have a quality are
   always described as "a/an <quality> <item>", with the exception of group D
   which is for armour items which are gramatically plural even if there is
   only one of the object, e.g. "leather leggings".


3.2 Object class properties

   These are stored in the file "objects.dat". It contains infos about
   different classes of objects, e.g. weapons, armor etc. The file is split
   in several tables. Here is an overview:

   pos   size     desc                        entries   bytes per entry
   0000  Int16    unknown, always 0x010f
   0002  0x80     melee weapons table         16         8 bytes
   0082  0x30     ranged weapons table        16         3 bytes
   00b2  0x80     armour and wearables table  32         4 bytes
   0132  0x0c00   critters table              64        48 bytes
   0d32  0x30     containers table            16         3 bytes
   0d62  0x20     lights info table           16         2 bytes
   0d82  0x20     unknown, maybe jewelry info table
   0da2  0x40     animation object table      16         4 bytes
   0de2           end

   * melee weapons table

     0000   Int8   damage modifier for Slash attack
     0001   Int8   damage modifier for Bash attack
     0002   Int8   damage modifier for Stab attack
     0003   3      unknown
     0006   Int8   skill type (3: sword, 4: axe, 5: mace, 6: unarmed)
     0007   Int8   durability

   * ranged weapons table

     0000   Int8   unknown
     0001   Int8   unknown
     0002   Int8   durability

   * armour and wearables table

     0000   Int8   protection
     0001   Int8   durability
     0002   Int8   unknown
     0003   Int8   category:
                   00: shield
                   01: body armour
                   03: leggings
                   04: gloves
                   05: boots
                   08: hat
                   09: ring

   * critters table

     0000   Int8   unknown

   * containers table

     0000   Int8   capacity
     0001   Int8   objects accepted (0xFF means any)
     0002   Int8   unknown

   * lights info table

     0000   Int8   light brightneess
     0001   Int8   duration (00: does't go out, e.g. taper of sacrifice)

   * jewelry info table (?)

   * animation object table

     0000   Int8   unknown
     0001   Int8   start frame (from animo.gr)
     0002   Int8   number of frames
     0003   Int8   unknown


3.3 Traps

   Traps have various effects on the game world. Traps have object IDs from
   0x0180 to 0x0190

   0180  Damage trap
   0181  Teleport trap
   0182  Arrow trap
   0183  "Do" trap
   0184  Pit trap
   0185  Change terrain trap
   0186  Spell trap
   0187  Create object trap
   0188  Door trap
   0189  Ward trap
   018A  "Tell" trap
   018B  Delete object trap
   018C  Inventory trap
   018D  Set variable trap
   018E  Check variable trap
   018F  Combination trap
   0190  Text string trap


   * Teleport trap (ID 0181)

     This trap teleports the player. The destination level is given by the
     trap z position (0 ==> remain on the current level). The destination
     tile coordinates are given by the "Unk2" and "quality" fields.

   * Pit trap (ID 0184)

     This is probably a bottomless pit that drops the player through to the
     next level.

   * Create object trap (ID 0187)

     This trap creates an object when it is set off. The link field
     points at the object to create.

   * Door trap (ID 0188)

     When set off, this trap opens or shuts a door. The link field
     points at the lock, if the door has one.

   * Text string trap (ID 0190)

     This trap causes the player to get a text message when it is set off. The
     "Owner / special" field of the object definition contains the string number per
     level, in game string block 0009. The actual string number printed is
     (64*level + unk2).


4.0 Game strings

   Game strings are stored in the file "strings.pak", and uses a Huffman
   compression scheme to store its strings. The first 2 bytes of the file give
   the number of nodes in the tree. Then follow the nodes themselves, 4 bytes
   each:

   0000   Int8   char symbol
   0001   Int8   parent node
   0002   Int8   left child
   0003   Int8   right child

   The last node stored in the file is the head of the tree. Following the
   nodes is a 16-bit word giving the number of string blocks in the
   file. Then follows the block directory, 6 bytes per block as follows:

   0000   Int16   block number
   0002   Int32   offset in file of start of block

   Each block contains a variable number of strings. The block header is:

   0000   Int16   no. of strings
   0002   Int16   relative offset from end of block header to first string
   0004   Int16   relative offset to second string
   ...

   Strings are compressed using the Huffman tree in the usual way. Bits are
   extracted big-endian i.e. rotated out of the top of each byte in turn.
   Starting with the root node (last node), if a 1 bit is encountered the right
   branch is taken, otherwise take the left. Repeat until a leaf (node with -1
   for its children) is reached, at which point output the symbol for that node.
   For the next bit we start again from the root. End of string is marked with a
   `|' character. The remaining bits in the last byte are unused.

   * game strings contents

     block 0001: general UI strings
     block 0002: character creation strings, mantras (?)
     block 0003: wall text/scroll/book/book title strings (*)
     block 0004: object descriptions (*)
     block 0005: object "look" descriptions, object quality states
     block 0006: spell names
     block 0007: conversation partner names, starting at string 17 for conv 1
     block 0008: text on walls, signs
     block 0009: text trap messages
     block 000a: wall/floor description text
     block 0018: debugging strings (not used ingame)
     block 0c00: intro cutscene text
     block 0c01: ending cutscene text
     block 0c02: tyball cutscene text
     block 0c03: arial cuscene text (?)
     block 0c18: dream cutscene 1 text "arrived"
     block 0c19: dream cutscene 2 text "talismans"
     block 0c1a-0c21: garamon cutscene texts
     block 0e01-0f3a: conversation strings

     Block 0003 contains text/scroll etc. strings. The exact string to use for
     books, scrolls or other text object is in the link2 field. It is calculated
     as link2 - 0x0200. For each level, 32 string slots are available.

     Block 0004 contains the object descriptions. The article (e.g. 'a' or
     'an') is separated with an underscore '_'. When a '&' is in the string,
     it separates the plural of the object's name. The complete text string is
     "you see <article> <mood> <description> [named <npc-name>]. <mood> can be
     one of "mellow" or "upset".

     In the uw_demo, the 0cXX blocks and many of the conversation string
     blocks aren't available.


4.1 Conversations

   Conversations are stored in the file "cnv.ark". File header:

   0000   Int16   number of conversation slots in file
   0002   Int32   offset to conversation slot #0
   ...

   If an offset is 0, the conversation slot is empty and no conversation is
   available. The name of the conversation partner is stored in string block
   0007, as string number (conversation slot number - 0x0e00 +16).

   The conversation header looks like this:

   0000   Int32   unknown1, always seems to be 0x0828, or 28 08
   0004   Int32   code size in number of instructions (16-bit words)
   0008   Int16   unknown2, always seems to be 0x0000
   000A   Int16   game strings block to use
   000C   Int16   number of stack space reserved for private globals
   000E   Int16   number of imported globals (functions + variables)
   0010           start of imported functions list

   One import record describes builtin (or imported) functions and game
   global variables used by the conversation:

   0000   Int16   length of function name
   0002   n*char  name of function
   n+02   Int16   ID (builtin) / memory address (variable)
   n+04   Int16   unknown, always seems to be 1
   n+06   Int16   import type (0x010F=variable, 0x0111=builtin)
   n+08   Int16   return type (0x0000=void, 0x0129=int, 0x012B=string)

   Each conversation has a set of private global variables that are saved
   across conversations. The initial size of them are stored in the file
   babglobals.dat. When a game is saved, the globals are in the file
   bglobals.dat. The layout of both is as follows:

   0000   Int16     number of conversation slot
   0002   Int16     size of private global data for that conv.
   0004   n*Int16   all globals for that slot (omitted in babglobals.dat)
   ...              repeat until file end

   On conversation start the game globals listed in the import table is
   copied to the memory address in the private globals. At end of conversation
   they are copied back to the game globals.

   * Memory layout

     0000    imported globals (copied on start) (usually 0x001f long)
     0020    private conversation globals
     0020+n  stack begin (ascends up)

   * Conversation assembler language

   The conversation code is an assembler-like languages with a set of opcodes.
   It runs on a 16-bit virtual machine with a stack and a result register for
   imported functions. The language set is described here:

   Opcode         no. immediate operands
   |   Name       | no. stack operands
   |   |          | | No. values saved to stack
   |   |          | | |  Action
   |   |          | | |  |
   00  NOP        0 0 0  do nothing.
   01  OPADD      0 2 1  push s[0] + s[1]
   02  OPMUL      0 2 1  push s[0] * s[1]
   03  OPSUB      0 2 1  push s[1] - s[0]
   04  OPDIV      0 2 1  push s[1] / s[0]
   05  OPMOD      0 2 1  push s[1] % s[0]
   06  OPOR       0 2 1  logical OR of top two values.
   07  OPAND      0 2 1  logical AND of top two values.
   08  OPNOT      0 1 1  logical NOT of top value.
   09  TSTGT      0 2 1  greater-than, nonzero if s[1] > s[0].
   0A  TSTGE      0 2 1  greater-than-or-equal.
   0B  TSTLT      0 2 1  less-than.
   0C  TSTLE      0 2 1  less-than-or-equal.
   0D  TSTEQ      0 2 1  equality. Nonzero if s[1] == s[0].
   0E  TSTNE      0 2 1  non-equal.
   0F  JMP        1 0 0  jump absolute. address is measured in words from the
                         start of the code.
   10  BEQ        1 1 0  branch on equal. Pop a value, branch relative if zero.
   11  BNE        1 1 0  branch on Not Equal. As BEQ but branch if the value
                         popped is non-zero.
   12  BRA        1 0 0  branch. Always branch relative to the offset address.
   13  CALL       1 0 1  call subroutine. Push the next instruction address and
                         jump to the absolute address (in words) given.
   14  CALLI      1 0 0  call imported subroutine.
   15  RET        0 1 0  return from subroutine. Pop the return address off the
                         stack and jump to it.
   16  PUSHI      1 0 1  push immediate value onto the stack.
   17  PUSHI_EFF  1 0 1  push effective address onto the stack. The value
                         pushed is the current frame pointer address plus the
                         immediate operand. This allows local variables and
                         function parameters.
   18  POP        0 1 0  pop a value from the stack (and throw it away).
   19  SWAP       0 2 2  swap the top two stack values.
   1A  PUSHBP     0 0 1  push the current frame pointer onto the stack.
   1B  POPBP      0 1 0  pop the frame pointer from the stack
   1C  SPTOBP     0 0 0  new frame. Set the frame pointer to the stack pointer.
   1D  BPTOSP     0 0 0  exit frame. Set the stack pointer to the frame pointer.
   1E  ADDSP      0 1 *  pop a value, add to the stack pointer. Used
                         to reserve stack space for variables.
   1F  FETCHM     0 1 1  pop address, push the value of the variable pointed to.
   20  STO        0 2 0  store s[0] in the variable pointed to by s[1].
   21  OFFSET     0 2 1  array offset. Add s[1] - 1 to the effective address in
                         s[0], push this as a new effective address.
   22  START      0 0 0  start program.
   23  SAVE_REG   0 1 0  pop a value from the stack and store it in the result
                         register.
   24  PUSH_REG   0 0 1  push the value of the result register on the stack.
   25  STRCMP     ? ? ?  string compare.
   26  EXIT_OP    0 0 0  end program (?)
   27  SAY_OP     0 1 0  NPC says something. Print a conversation string (from
                         the stack).
   28  RESPOND_OP ? ? ?  respond (?)
   29  OPNEG      0 1 1  negate. s[0] -> -s[0].

   (*) ADDSP, of course, doesn't actually push anything onto the stack, but its
       effect on the stack pointer is of pushing as many values as its operand
       specifies.
   (?) I haven't yet encountered these in the wild, so don't know exactly what
       they do.

   * Conversation text substitutions

     In text strings printed by SAY_OP or a imported function (like
     "babl_menu") there may be strings like @SS1 or @GS8 that are substituted
     with other text. The format of the "format string" is like this:

     @XY<num>

     X: source of variable to substitute, one of these: GSP
        G: game global variable
        S: stack variable
        P: pointer variable
     Y: type of variable, one of these: SI
        S: value is a string number into current string block
        I: value is an integer value
     <num>: decimal value

     For pointer variables, the num value determines the location of the
     pointer relative to the stack. It usually refers to variables passed
     to a function (since they were push'ed onto the stack).

     For stack variables, the num value determines which stack value is taken
     from the current local variables. The value to take is basep + <num>

     For global variables, the value describes the globals position in memory,
     at the front where the imported game globals and private globals are
     stored.

     Example:
     @SS2 means: print string with string number found at basep + 2
     @PI-3 means: print int value pointed to by pointer at basep - 3
     @GS8 means: print string from global var #8

   * Conversation builtin functions

     Here are listed all builtin functions:

     id=0000 name="babl_menu" ret_type=int
     parameters:   s[0]: unknown
                   s[1]: pointer to list of string id's; ends with id == 0
     description:  shows a menu of further questions the user can select
     return value: number of selected response
     -------------------------------------------------------------------------

     id=0001 name="babl_fmenu" ret_type=int
     parameters:   s[0]: unknown, always 0x0000
                   s[1]: pointer to list of string id's; ends with id == 0
                   s[2]: unknown, points to 3 values
     description:  ???
     return value: number of selected response
     -------------------------------------------------------------------------

     id=0003 name="babl_ask" ret_type=int
     parameters:   s[0]: unknown, always 0x0000
     description:  lets the user type in a string
     return value: ???, string handle which can be printed with @SS1 when put
                   to stack on basep + 1
     -------------------------------------------------------------------------

     id=0007 name="contains" ret_type=int
     parameters:   s[0]: pointer to first string handle (?)
                   s[1]: pointer to second string handle (?)
                   s[2]: unknown
     description:  checks if the first string has the second string inside
     return value: 1 when the string was found

     -------------------------------------------------------------------------

     id=000f name="get_quest" ret_type=int
     parameters:   s[0]: sub-category ???
                   s[1]: pointer to index ???
     description:  returns a quest flag (??)
     return value: quest value (??)
     -------------------------------------------------------------------------

     id=0010 name="set_quest" ret_type=void
     parameters:   s[0]: value to set
                   s[1]: pointer to sub-category ???
                   s[2]: pointer to index ???
     description:  sets a quest value (??)
     return value: none
     -------------------------------------------------------------------------

     id=0011 name="sex" ret_type=string
     parameters:   s[0]: 
     description:  
     return value: ???
     -------------------------------------------------------------------------

     id=0012 name="show_inv" ret_type=int
     parameters:   s[0]: unknown
                   s[1]: pointer to ???
                   s[2]: pointer to ???
     description:  lets the player show an item to the NPC, the player gets
                   the item back
     return value: ???
     -------------------------------------------------------------------------

     id=0014 name="give_ptr_npc" ret_type=int
     parameters:   s[0]: unknown, value ???
                   s[1]: pointer to ???
                   s[2]: pointer to quantity to transfer???
     description:  player hands over an item to NPC
     return value: unused
     -------------------------------------------------------------------------

     id=0015 name="take_from_npc" ret_type=int
     parameters:   s[0]: quantity (?)
                   s[1]: pointer to item ID
     description:  gives the player an item
     return value: 1: ok, 2: player has no space left
     -------------------------------------------------------------------------

     id=0031 name="find_barter" ret_type=int
     parameters:   s[0]: quantity
                   s[1]: item ID to find
     description:  searches for item in barter area
     return value: 1 when found (?)
     -------------------------------------------------------------------------

     id=0032 name="find_barter_total" ret_type=int
     parameters:   s[0]: ???
                   s[1]: pointer to number of found items
                   s[2]: pointer to
                   s[3]: pointer to
                   s[4]: pointer to item ID to find
     description:  searches for item in barter area
     return value: 1 when found (?)
     -------------------------------------------------------------------------


5.0 Critter Animation

   Critter animations are stored in the folder "crit". The file "assoc.anm"
   holds data for each of the 32 animations and for the 64 NPC types. The file
   starts with 8 bytes for the name of each animation. Shorter strings are
   padded with zeros. Empty strings denote animations not available (for
   the "uw_demo").

   Next comes a table of infos for each NPC. The table is 64 entries (0x0080)
   long:

   0000   Int8   anim
   0001   Int8   auxpal

   The "anim" field specifies which one of the 32 animations to take for a
   given NPC number (NPC object ID - 0x0040).

   The "auxpal" value describes which auxiliary palette to use. There are
   several critters that share the same animations but use different palettes,
   e.g. the bat and the vampire bat uses the same anim value, but different
   auxpals.

   Animation for each critter is stored in a file like "CrXXpage.nYY", where
      XX = animation number (=anim), YY = page number
      XX and YY are octal numbers

   There may be more than one page for each animation file.
   The file starts with a header:

   pos     length          desc.
   0000    Int8            anim slot base
   0001    Int8            number of anim slots (=nslot)
   0002    nslot*Int8      list of segment indices

   After this, a list of segment follows, which contains up to 8 frame indices
   for every segment.

   nslot+2 Int8            number of anim segments (=nsegs)
           8*nsegs         anim frame indices

   Then the auxiliary palettes follow:

           Int8            number of aux palettes (=npals)
           npals*32        allaux palette indices in blocks of 32

   Next is a list of all frames and their offsets into the file:

           Int8            number of frame offsets (=noffsets)
           Int8            compression type? (always 06)
           noffsets*Int16  absolute offsets to frame headers

   Each animation is stored in a segment, which can contain a number of
   frames (stored in the "animation frame indices"). Each list ends with a
   0xFF entry.

   frame header

   0000    Int8       width
   0001    Int8       height
   0002    Int8       hotspot x
   0003    Int8       hotspot y
   0004    Int8       compression type; (06: 5-bit word size)
   0005    Int16      data length in number of words
   0007               start of rle-encoded image data (see 2.3)

   The hotspot coordinates are to "pin" the image at a specific position.

   Here is a list of files and their contents:

   crXX file   assoc name
   cr00        gngob32, green goblin
   cr01        skela, skeleton
   cr02        lizman, green lizard man
   cr03        bat
   cr04        wiza, yellow male wizard
   cr05        spider, brown spider
   cr06        gazer
   cr07        troll
   cr10        femwiz, female wizard
   cr11        slug, green slug
   cr12        fire, fire elemental
   cr13        ghoul
   cr14        ?
   cr15        ghost
   cr16        ?
   cr17        reaper
   cr20        rat
   cr21        femfite, female fighter
   cr22        imp
   cr23        golem, gray golem
   cr24        hedless, headless
   cr25        wizb, blue female wizard
   cr26        rotgrub, green rotworm
   cr27        wisp
   cr30        batskull
   cr32        fight32, male fighter
   cr33        dwarf32
   cr35        tybal, tyball


5.1 Cutscene Animations

   Cutscene animations are stored in folder "cuts". Text strings for cutscenes
   can be found in string blocks 0c00 through 0c21. Here is an overview of
   files contents:

      * = not in "static" install

      cs???.n00   anim control files (?)

      cs000.n01   black screen
      cs000.n02 * garamon in swirling air
      cs000.n03   garamon talking
      cs000.n04 * garamon talking
      cs000.n05 * garamon talking
      cs000.n06 * garamon in swirling air
      cs000.n07   garamon appearing
      cs000.n10   intro w/ tyball stealing princess, troll and guards etc.
      cs000.n11   almric talking, on throne
      cs000.n12   almric talking, closeup
      cs000.n15   guard talking
      cs000.n16 * guard talking
      cs000.n17 * guard talking
      cs000.n20   mountain scene, avatar taken to the abyss
      cs000.n21 * mountain scene
      cs000.n22   abyss doors closed, from outside
      cs000.n23   doors closed, from inside, w/ avatar
      cs000.n24   guard talking, with purple background
      cs000.n25 * guard talking, with purple background

      cs001.n01   ship approaching, abyss collapsing
      cs001.n02   ship taking avatar on board
      cs001.n03   almric talking, on ship
      cs001.n04   almric talking, on ship
      cs001.n05 * almric talking, on ship, birds in background
      cs001.n06   arial talking
      cs001.n07   arial talking
      cs001.n10   abyss collapsing, ship sails away

      cs002.n01   dying tyball talking
      cs002.n02 * dying tyball talking
      cs002.n03 * dying tyball talking
      cs002.n04 * dying tyball, dying

      cs003.n01   arial talking
      cs003.n02 * arial talking

      cs011.n01   "ultima underworld the stygian abyss" splash screen anim
      cs012.n01   acknowledgements
      cs013.n01   goblet with letters "in"
      cs014.n01   goblet with letters "sa"
      cs015.n01   goblet with letters "hn"

      cs400.n01   "look" graphics for windows to abyss volcano core
      cs401.n01   grave stones

      cs402.n01   death skulls w/ silver sapling
      cs403.n01   death skulls animation
      cs403.n02   death skull end anim

      cs404.n01   anvil graphics
      cs410.n01   map piece showing some traps

   The cutscene files are done with Amiga's DeluxePaint Animator (file
   extension *.anm). The complete description can be found in the zip file
   "anmformt.zip" in the "misc" folder. Here's a short overview for usage in
   uw1:

   The files, "large page files", consist of a header, followed by one or
   more large pages, where each page can store one or more animation frames.
   A large page is always 64k big, except for the last page (which is
   truncated at the end of usable data).

   The file starts with a "large page file header":

      0000   Int32   file ID, always contains "LPF "
      ...
      0006   Int16   number of large pages in the file
      0008   Int32   number of records in the file
      ...
      0010   Int32   content type, always contains "ANIM"
      0014   Int16   width in pixels
      0016   Int16   height in pixels

   The whole header is 128 bytes long. After the header color cycling info
   follows (which also is 128 bytes long), which is not used in uw1. Then
   comes the color palette:

      0000   Int8    intensity for blue, ranges from 0..255
      0001   Int8    intensity for green
      0002   Int8    intensity for red
      0003   Int8    padding byte
      ...            repeated for all 256 color indices

   After the palette an array with 256 "large page descriptors" follow:

      0000   Int16   number of first record in the large page
      0002   Int16   number of records in the large page
      0004   Int16   total number of bytes, excluding header

   Unused descriptors contain no information. After the array, the large pages
   start. A "large page" has the following layout:

      0000   lpdesc  large page descriptor
      0006   Int16   empty
      0008   Int16   length of first record
      000A   Int16   length of second record
      ...

   The large page descriptor is repeated for the current large page. A record
   contains a frame (which may depend on the previous frame). The start can be
   calculated by summing up the length of the previous records. A "record" has
   the following structure:

      0000   Int8    unknown
      0001   Int8    flag
      0002   Int16   extra offset, when flag != 0
      0004           start of compressed data

   The extra offset must be even (when odd, add an extra 1).

   The compression scheme is a variation of run-length encoding, with some
   extras. There are "dump", "run" and "skip" records. "dump" records just
   copy the next bytes to the output buffer. "run" records get the next byte
   and repeat them according to the count. A "skip" record skips pixels in the
   output buffer (it is assumed that the previous decoded image is still in
   the buffer).

   First, read a signed Int8. If it is positive, dump that many bytes.
   If it is 0, the next two Int8's are the count and the pixel byte for a
   "run" record. For negative values, remove the sign bit. If the resulting
   byte is != 0, skip that many bytes in the output, else a "long" operation
   is started.

   For the long operation, retrieve the next two Int8's, treating as a little
   endian signed Int16. If the value is 0, the decoding ends. If the value
   is > 0, skip that many bytes in the output. For values < 0, remove the sign
   bit. If the resulting value is >= 0x4000, we have a "run" record with
   count = value & 0x3fff and the next Int8 as the pixel index. If the value
   is <= 0x4000, we have a long "dump" record.

   Here is some C code to describe the decoding:

      while(true)
      {
         Int8 cnt = get_next_src8();

         if (cnt>0) dump_pixels(cnt);
         if (cnt==0) run_pixels(get_next_src8(),get_next_src8());
         if (cnt<0)
         {
            cnt &= 0x7f;
            if (cnt!=0) skip_pixels(cnt);
            else
            {
               // we have a "long" operation
               Int8 cnt2 = get_next_src16();
               if (cnt2>0)
                  skip_pixels(cnt2);
               else
               if (cnt2==0)
                  break;
               else
               {
                  cnt2 &= 0x7fff;

                  if (cnt2>=0x4000)
                     run_pixels(cnt2-0x4000,get_next_src());
                  else
                     dump_pixels(cnt2);
               }
            }
         }
      }


6.0 Savegame format

   Savegames are stored in folders called "SaveN", where N is the number
   of the save game. Ultima Underworld only allows 4 save game slots.

   The file "player.dat" contains the main character data. The first 220 bytes
   are encrypted with a rather simple algorithm. Byte 0 in the file is the
   starting xor value. Byte 1 is xor'ed with xorvalue + 3, and for each next
   byte, the xorvalue is incremented by 3. A simple implementation in C is here:

      // descramble data
      unsigned char xorvalue = data[0];
      unsigned char incrnum = 3;

      for(int i=1; i<=220; i++)
      {
         if (i==81) incrnum = 3;
         data[i] ^= (xorvalue+incrnum);
         incrnum += 3;
      }

   After decryption, the file contains the following:

   0000   Int8    unused (was starting xor value)
   0001   14*char character name
   ...
   001F   Int8    Strength
   0020   Int8    Dexterity
   0021   Int8    Intelligence
   0022   Int8    Attack
   0023   Int8    Defense
   0024   Int8    Unarmed
   0025   Int8    Sword
   0026   Int8    Axe
   0027   Int8    Mace
   0028   Int8    Missile
   0029   Int8    Mana
   002A   Int8    Lore
   002B   Int8    Casting
   002C   Int8    Traps
   002D   Int8    Search
   002E   Int8    Track
   002F   Int8    Sneak
   0030   Int8    Repair
   0031   Int8    Charm
   0032   Int8    Picklock
   0033   Int8    Acrobat
   0034   Int8    Appraise
   0035   Int8    Swimming
   ...
   0037   Int8    max. vitality
   0038   Int8    current mana
   0039   Int8    max. mana
   ...
   003E   Int8    character level
   ...
   0045   3*8bits rune flags (*)
   ...
   004D   Int16   weight in 0.1 stones
   004F   Int32   experience in 0.1 points
   ...
   0055   Int16   x-position in level
   0057   Int16   y-position
   0057   Int16   z-position
   005B   Int16   heading
   005D   Int16   dungeon level
   ...
   00DD   Int8    current vitality

   (*) The rune field is a bitfield, where an 1 indicates an available
       rune. Bits are seen from most to least significant. The 'A' rune is
       stored in bit 7 of the first field.

   todo: how items are stored


7.0 3D objects

   todo


8.0 Misc. stuff

8.1 Combining objects

   In the Ultima Underworlds, when you `apply' certain objects to one another
   in your inventory a new object is created. For example,
   pole + strong thread = fishing pole. The mechanism for this is very simple
   and is controlled by the file "cmb.dat" in the data/ directory.

   This file contains a table of 3 16-bit words for each allowable
   combination: `source1', `source2', `newobject' in that order. 3 zeros mark
   the end of the table. The low 9 bits of each word is the object ID. If an
   object of type source1 is applied to an object of type source2 (or vice
   versa) an object of type newobject is created. The top bit of each of the
   source words indicates whether that object is destroyed in the process: if
   it is a 1, the object is destroyed. (It is always the case that at least
   one of the source objects is destroyed: you can't create something from
   nothing, at least not this way).

8.2 Graves

   Graves. (Dig those graves!) There are 2 bitmaps available for graves: 28
   and 29 in tmobj.gr. Which one is drawn in the model depends on the low bits
   of the "state" field, as usual. Headstone text is determined by the "link"
   field: the high (512) bit seems always to be set, the rest is the string
   index in the object message block 0008. This also serves as an index into
   grave.dat which in turn gives a unique grave ID.

   Large headstone images live in the cutscene file cuts/cs401.n01, one frame
   each, indexed by grave ID.

8.3 Terrain texture properties

   The file terrain.dat in the data directory contains information on the
   terrain types represented by the various wall and floor textures. There is
   a 16-bit word per texture, up to a maximum of 256 walls and 256 floors.
   Floor data therefore starts at file offset 0x200. Terrain types are:

    0000    Normal (solid) wall or floor
    0002    Ankh mural (shrines)
    0003    Stairs up
    0004    Stairs down
    0005    Pipe
    0006    Grating
    0007    Drain
    0008    Chained-up princess
    0009    Window
    000a    Tapestry
    000b    Textured door (used for the lock to the Key of Infinity)
    0010    Water (not waterfall)
    0020    Lava (not lavafall)

eof
